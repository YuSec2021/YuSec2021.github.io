{"meta":{"title":"YuSec2021","subtitle":"YuSec Github Page","description":"Record Some Tricks","author":"YuSec","url":"https://YuSec2021.github.io","root":"/"},"pages":[],"posts":[{"title":"test1","slug":"test1","date":"2022-02-24T09:37:04.000Z","updated":"2022-02-24T09:38:02.497Z","comments":true,"path":"2022/02/24/test1/","link":"","permalink":"https://yusec2021.github.io/2022/02/24/test1/","excerpt":"","text":"# Test1 #include &lt;stdio.h>int main() &#123; return 0;&#125;","categories":[],"tags":[]},{"title":"虚函数及虚表逆向浅析","slug":"VirtualFunction","date":"2022-02-17T10:00:09.000Z","updated":"2022-02-24T09:09:27.252Z","comments":true,"path":"2022/02/17/VirtualFunction/","link":"","permalink":"https://yusec2021.github.io/2022/02/17/VirtualFunction/","excerpt":"","text":"# Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： int main() &#123; struct Test&#123; int a; int b; int c; &#125;; Test* test = new Test; test->a = 100; printf(\"%d\", *test);&#125;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： #include &lt;iostream&gt; using namespace std; struct Test &#123; int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); &#125;; void Test::func1() &#123; printf(&quot;func1&quot;); &#125; void Test::func2() &#123; printf(&quot;func2&quot;); &#125; void Test::func3() &#123; printf(&quot;func3&quot;); &#125; int main() &#123; Test* test = new Test; test-&gt;a = 100; test-&gt;func1(); printf(&quot;%d&quot;, *test); &#125; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; _DWORD *v4; // [esp+Ch] [ebp-DCh] void *v5; // [esp+14h] [ebp-D4h] _DWORD *v6; // [esp+E0h] [ebp-8h] __CheckForDebuggerJustMyCode(&amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\"%d\", *v4); return 0;&#125;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： _DWORD *__thiscall sub_411880(_DWORD *this) &#123; *this = &amp;Test::`vftable'; return this; &#125; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： int __cdecl main(int argc, const char **argv, const char **envp) &#123; _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF _DWORD *v5; // [esp+4h] [ebp-88h] _DWORD *v6; // [esp+8h] [ebp-84h] int v7; // [esp+Ch] [ebp-80h] char v8[108]; // [esp+10h] [ebp-7Ch] BYREF int v9; // [esp+88h] [ebp-4h] if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; &#125; 进入 sub_401FE0: _DWORD *__thiscall sub_401FE0(_DWORD *this) &#123; int i; // [esp+4h] [ebp-14h] *this = &amp;EASYRE::`vftable'; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, &quot; 03\\&quot;3 0 203\\&quot; $ &quot;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i &lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; &#125; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End 来到校验 flag 的函数，可以发现存在虚函数的特征： BOOL __thiscall sub_4024B0(_DWORD *this, int flag) &#123; BOOL result; // eax this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) &#123; (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; &#125; return result; &#125; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -&gt; 0x4124F0 -&gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -&gt; 0x4124FC -&gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -&gt; 0x41250C -&gt; sub_402A00 映射： BOOL __thiscall sub_4024B0(_DWORD *this, int flag)&#123; BOOL result; // eax this[2] = flag; result = 0; if ( sub_402500() ) &#123; sub_4026E0(); if ( sub_402A00() ) result = 1; &#125; return result;&#125;# End","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://yusec2021.github.io/tags/Reverse/"},{"name":"C++","slug":"C","permalink":"https://yusec2021.github.io/tags/C/"}]}],"categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://yusec2021.github.io/tags/Reverse/"},{"name":"C++","slug":"C","permalink":"https://yusec2021.github.io/tags/C/"}]}