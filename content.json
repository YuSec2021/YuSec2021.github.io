{"meta":{"title":"YuSec2021","subtitle":"YuSec Github Page","description":"Record Some Tricks","author":"YuSec","url":"https://YuSec2021.github.io","root":"/"},"pages":[],"posts":[{"title":"test1","slug":"test1","date":"2022-02-24T09:37:04.000Z","updated":"2022-02-24T09:38:02.497Z","comments":true,"path":"2022/02/24/test1/","link":"","permalink":"https://yusec2021.github.io/2022/02/24/test1/","excerpt":"","text":"# Test1 &lt;!–code￼0–&gt;","categories":[],"tags":[]},{"title":"虚函数及虚表逆向浅析","slug":"VirtualFunction","date":"2022-02-17T10:00:09.000Z","updated":"2022-02-24T09:09:27.252Z","comments":true,"path":"2022/02/17/VirtualFunction/","link":"","permalink":"https://yusec2021.github.io/2022/02/17/VirtualFunction/","excerpt":"","text":"# Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼0–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼1–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼2–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼3–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼4–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼5–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼6–&gt; 进入 sub_401FE0: &lt;!–code￼7–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼8–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼9–&gt; 映射： &lt;!–code￼10–&gt; # End 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼11–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼12–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼13–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼14–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼15–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼16–&gt; 进入 sub_401FE0: &lt;!–code￼17–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼18–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼19–&gt; 映射： &lt;!–code￼20–&gt; # End demo2： &lt;!–code￼21–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼22–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼23–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼24–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼25–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼26–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼27–&gt; 进入 sub_401FE0: &lt;!–code￼28–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼29–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼30–&gt; 映射： &lt;!–code￼31–&gt; # End VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼32–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼33–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼34–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼35–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼36–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼37–&gt; 进入 sub_401FE0: &lt;!–code￼38–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼39–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼40–&gt; 映射： &lt;!–code￼41–&gt; # End 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼42–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼43–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼44–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼45–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼46–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼47–&gt; 进入 sub_401FE0: &lt;!–code￼48–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼49–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼50–&gt; 映射： &lt;!–code￼51–&gt; # End # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼52–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼53–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼54–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼55–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼56–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼57–&gt; 进入 sub_401FE0: &lt;!–code￼58–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼59–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼60–&gt; 映射： &lt;!–code￼61–&gt; # End # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼62–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼63–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼64–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼65–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼66–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼67–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼68–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼69–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼70–&gt; 进入 sub_401FE0: &lt;!–code￼71–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼72–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼73–&gt; 映射： &lt;!–code￼74–&gt; # End 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼75–&gt; 进入 sub_401FE0: &lt;!–code￼76–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： # Reverse 中虚函数 / 虚表浅析 # this 指针 在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针： 一个简单的 demo 来测试一下 this 指针： &lt;!–code￼77–&gt; 可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址： 关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同 demo2： &lt;!–code￼78–&gt; 这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 func1 、 func2 、 func3 ，我们注意到这里 call 的函数内容来自 [edx] 、 [edx+4] 、 [edx+8] VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址： 但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置： # IDA 加载该程序 直接来到 main 函数： &lt;!–code￼79–&gt; 根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果： &lt;!–code￼80–&gt; 这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 virtual function table 也就是虚函数表： &lt;!–code￼81–&gt; 根据前面 VS 中的调试可以知道这个表中存放的是增量链接： 基本上关于虚函数在 IDA 中的体现就介绍完了 # 一道逆向题 SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析： &lt;!–code￼82–&gt; 进入 sub_401FE0: &lt;!–code￼83–&gt; 该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址： 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼84–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼85–&gt; 映射： &lt;!–code￼86–&gt; # End 来到校验 flag 的函数，可以发现存在虚函数的特征： &lt;!–code￼87–&gt; 这里 this 指针指向的首地址是 0x4124E4 ，根据偏移可以映射： &lt;!–code￼88–&gt; 映射： &lt;!–code￼89–&gt; # End","categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://yusec2021.github.io/tags/Reverse/"},{"name":"C++","slug":"C","permalink":"https://yusec2021.github.io/tags/C/"}]}],"categories":[],"tags":[{"name":"Reverse","slug":"Reverse","permalink":"https://yusec2021.github.io/tags/Reverse/"},{"name":"C++","slug":"C","permalink":"https://yusec2021.github.io/tags/C/"}]}