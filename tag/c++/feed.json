{
    "version": "https://jsonfeed.org/version/1",
    "title": "YuSec2021 • All posts by \"c++\" tag",
    "description": "Record Some Tricks",
    "home_page_url": "https://YuSec2021.github.io",
    "items": [
        {
            "id": "https://yusec2021.github.io/2022/02/17/VirtualFunction/",
            "url": "https://yusec2021.github.io/2022/02/17/VirtualFunction/",
            "title": "虚函数及虚表逆向浅析",
            "date_published": "2022-02-17T10:00:09.000Z",
            "content_html": "<h2 id=\"reverse中虚函数虚表浅析\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针\"><a class=\"markdownIt-Anchor\" href=\"#this指针\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼0–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<h2 id=\"reverse中虚函数虚表浅析-2\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-2\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-2\"><a class=\"markdownIt-Anchor\" href=\"#this指针-2\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼1–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼2–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼3–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼4–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼5–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼6–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼7–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼8–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼9–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼10–&gt;</p>\n<h3 id=\"end\"><a class=\"markdownIt-Anchor\" href=\"#end\">#</a> End</h3>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<h2 id=\"reverse中虚函数虚表浅析-3\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-3\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-3\"><a class=\"markdownIt-Anchor\" href=\"#this指针-3\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼11–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼12–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序-2\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-2\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼13–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼14–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼15–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-2\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-2\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼16–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼17–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼18–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼19–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼20–&gt;</p>\n<h3 id=\"end-2\"><a class=\"markdownIt-Anchor\" href=\"#end-2\">#</a> End</h3>\n<p>demo2：</p>\n<p>&lt;!–code￼21–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<h2 id=\"reverse中虚函数虚表浅析-4\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-4\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-4\"><a class=\"markdownIt-Anchor\" href=\"#this指针-4\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼22–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼23–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序-3\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-3\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼24–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼25–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼26–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-3\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-3\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼27–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼28–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼29–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼30–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼31–&gt;</p>\n<h3 id=\"end-3\"><a class=\"markdownIt-Anchor\" href=\"#end-3\">#</a> End</h3>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<h2 id=\"reverse中虚函数虚表浅析-5\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-5\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-5\"><a class=\"markdownIt-Anchor\" href=\"#this指针-5\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼32–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼33–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序-4\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-4\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼34–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼35–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼36–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-4\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-4\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼37–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼38–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼39–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼40–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼41–&gt;</p>\n<h3 id=\"end-4\"><a class=\"markdownIt-Anchor\" href=\"#end-4\">#</a> End</h3>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<h2 id=\"reverse中虚函数虚表浅析-6\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-6\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-6\"><a class=\"markdownIt-Anchor\" href=\"#this指针-6\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼42–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼43–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序-5\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-5\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼44–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼45–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼46–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-5\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-5\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼47–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼48–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼49–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼50–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼51–&gt;</p>\n<h3 id=\"end-5\"><a class=\"markdownIt-Anchor\" href=\"#end-5\">#</a> End</h3>\n<h2 id=\"reverse中虚函数虚表浅析-7\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-7\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-7\"><a class=\"markdownIt-Anchor\" href=\"#this指针-7\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼52–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼53–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序-6\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-6\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼54–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼55–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼56–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-6\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-6\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼57–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼58–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼59–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼60–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼61–&gt;</p>\n<h3 id=\"end-6\"><a class=\"markdownIt-Anchor\" href=\"#end-6\">#</a> End</h3>\n<h3 id=\"ida加载该程序-7\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-7\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼62–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼63–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼64–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<h2 id=\"reverse中虚函数虚表浅析-8\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-8\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-8\"><a class=\"markdownIt-Anchor\" href=\"#this指针-8\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼65–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼66–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序-8\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-8\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼67–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼68–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼69–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-7\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-7\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼70–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼71–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼72–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼73–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼74–&gt;</p>\n<h3 id=\"end-7\"><a class=\"markdownIt-Anchor\" href=\"#end-7\">#</a> End</h3>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-8\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-8\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼75–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼76–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<h2 id=\"reverse中虚函数虚表浅析-9\"><a class=\"markdownIt-Anchor\" href=\"#reverse中虚函数虚表浅析-9\">#</a> Reverse 中虚函数 / 虚表浅析</h2>\n<h3 id=\"this指针-9\"><a class=\"markdownIt-Anchor\" href=\"#this指针-9\">#</a> this 指针</h3>\n<p>在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：</p>\n<p>一个简单的 demo 来测试一下 this 指针：</p>\n<p>&lt;!–code￼77–&gt;</p>\n<p>可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png\" alt=\"image-202202221821809\" loading=\"lazy\"></p>\n<p><strong>关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同</strong></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png\" alt=\"image-202202221821374\" loading=\"lazy\"></p>\n<p>demo2：</p>\n<p>&lt;!–code￼78–&gt;</p>\n<p>这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 <code>func1</code> 、 <code>func2</code> 、 <code>func3</code> ，我们注意到这里 call 的函数内容来自 <code>[edx]</code> 、 <code>[edx+4]</code> 、 <code>[edx+8]</code></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png\" alt=\"image-202202221822350\" loading=\"lazy\"></p>\n<p>VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png\" alt=\"image-202202221822816\" loading=\"lazy\"></p>\n<p>但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png\" alt=\"image-202202221822113\" loading=\"lazy\"></p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png\" alt=\"image-202202221822536\" loading=\"lazy\"></p>\n<h3 id=\"ida加载该程序-9\"><a class=\"markdownIt-Anchor\" href=\"#ida加载该程序-9\">#</a> IDA 加载该程序</h3>\n<p>直接来到 main 函数：</p>\n<p>&lt;!–code￼79–&gt;</p>\n<p>根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：</p>\n<p>&lt;!–code￼80–&gt;</p>\n<p>这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 <code>virtual function table</code>  也就是虚函数表：</p>\n<p>&lt;!–code￼81–&gt;</p>\n<p>根据前面 VS 中的调试可以知道这个表中存放的是增量链接：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png\" alt=\"image-202202221822914\" loading=\"lazy\"></p>\n<p>基本上关于虚函数在 IDA 中的体现就介绍完了</p>\n<h3 id=\"一道逆向题-9\"><a class=\"markdownIt-Anchor\" href=\"#一道逆向题-9\">#</a> 一道逆向题</h3>\n<p>SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：</p>\n<p>&lt;!–code￼82–&gt;</p>\n<p>进入 sub_401FE0:</p>\n<p>&lt;!–code￼83–&gt;</p>\n<p>该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：</p>\n<p><img src=\"https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png\" alt=\"image-202202221822478\" loading=\"lazy\"></p>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼84–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼85–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼86–&gt;</p>\n<h3 id=\"end-8\"><a class=\"markdownIt-Anchor\" href=\"#end-8\">#</a> End</h3>\n<p>来到校验 flag 的函数，可以发现存在虚函数的特征：</p>\n<p>&lt;!–code￼87–&gt;</p>\n<p>这里 this 指针指向的首地址是 <code>0x4124E4</code> ，根据偏移可以映射：</p>\n<p>&lt;!–code￼88–&gt;</p>\n<p>映射：</p>\n<p>&lt;!–code￼89–&gt;</p>\n<h3 id=\"end-9\"><a class=\"markdownIt-Anchor\" href=\"#end-9\">#</a> End</h3>\n",
            "tags": [
                "Reverse",
                "C++"
            ]
        }
    ]
}