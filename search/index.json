[{"content":"SUSCTF 2022 DigitalCircuits 前置分析 下载是一个main.exe，根据ico可以知道是python生成的exe文件，python中通过pyinstaller进行py转exe，在默认情况下，并且只有一个exe文件，所以猜测应该是-F进行转换，所以此时可以尝试用pyinstxtractor进行解包：\n生成一个_extracted文件夹：\n进入文件夹找到同名的pyc文件，对比正常的stuct.pyc文件发现少了16个字节的py头：\n将py头复制过去即可反编译，这里无法用在线反编译猜测应该是文件过大，所以采用python进行反编译：\n1  pip3 install uncompyle6   反编译（需要注意python的版本，3.9以上的好像反编译会失败）\n1  uncompyle6 -o ./ DigitalCircuits.pyc   基础功能代码分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  # uncompyle6 version 3.8.0 # Python bytecode 3.7.0 (3394) # Decompiled from: Python 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)] # Embedded file name: DigitalCircuits.py # Compiled at: 1995-09-28 00:18:56 # Size of source mod 2**32: 257 bytes import time def f1(a, b): if a == \u0026#39;1\u0026#39;: if b == \u0026#39;1\u0026#39;: return \u0026#39;1\u0026#39; return \u0026#39;0\u0026#39; def f2(a, b): if a == \u0026#39;0\u0026#39;: if b == \u0026#39;0\u0026#39;: return \u0026#39;0\u0026#39; return \u0026#39;1\u0026#39; def f3(a): if a == \u0026#39;1\u0026#39;: return \u0026#39;0\u0026#39; if a == \u0026#39;0\u0026#39;: return \u0026#39;1\u0026#39; def f4(a, b): return f2(f1(a, f3(b)), f1(f3(a), b)) def f5(x, y, z): s = f4(f4(x, y), z) c = f2(f1(x, y), f1(z, f2(x, y))) return (s, c) def f6(a, b): ans = \u0026#39;\u0026#39; z = \u0026#39;0\u0026#39; a = a[::-1] b = b[::-1] for i in range(32): ans += f5(a[i], b[i], z)[0] z = f5(a[i], b[i], z)[1] return ans[::-1] def f7(a, n): return a[n:] + \u0026#39;0\u0026#39; * n def f8(a, n): return n * \u0026#39;0\u0026#39; + a[:-n] def f9(a, b): ans = \u0026#39;\u0026#39; for i in range(32): ans += f4(a[i], b[i]) return ans def f10(v0, v1, k0, k1, k2, k3): s = \u0026#39;00000000000000000000000000000000\u0026#39; d = \u0026#39;10011110001101110111100110111001\u0026#39; for i in range(32): s = f6(s, d) v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1))) v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3))) return v0 + v1 k0 = \u0026#39;0100010001000101\u0026#39;.zfill(32) k1 = \u0026#39;0100000101000100\u0026#39;.zfill(32) k2 = \u0026#39;0100001001000101\u0026#39;.zfill(32) k3 = \u0026#39;0100010101000110\u0026#39;.zfill(32) flag = input(\u0026#39;please input flag:\u0026#39;) if flag[0:7] != \u0026#39;SUSCTF{\u0026#39; or flag[(-1)] != \u0026#39;}\u0026#39;: print(\u0026#39;Error!!!The formate of flag is SUSCTF{XXX}\u0026#39;) time.sleep(5) exit(0) flagstr = flag[7:-1] if len(flagstr) != 24: print(\u0026#39;Error!!!The length of flag 24\u0026#39;) time.sleep(5) exit(0) else: res = \u0026#39;\u0026#39; for i in range(0, len(flagstr), 8): v0 = flagstr[i:i + 4] v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[(i + 1)]))[2:].zfill(8) + bin(ord(flagstr[(i + 2)]))[2:].zfill(8) + bin(ord(flagstr[(i + 3)]))[2:].zfill(8) v1 = bin(ord(flagstr[(i + 4)]))[2:].zfill(8) + bin(ord(flagstr[(i + 5)]))[2:].zfill(8) + bin(ord(flagstr[(i + 6)]))[2:].zfill(8) + bin(ord(flagstr[(i + 7)]))[2:].zfill(8) res += f10(v0, v1, k0, k1, k2, k3) if res == \u0026#39;001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111\u0026#39;: print(\u0026#39;True\u0026#39;) else: print(\u0026#39;False\u0026#39;) time.sleep(5)   根据if可以得知传入的参数非0即1，所以可以知道应该是逻辑指令，f1就是\u0026amp;，f2就是|，f3取非，所以这部分就跟题目名称对上了，数电三大基础逻辑运算：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def f1(a, b): if a == \u0026#39;1\u0026#39;: if b == \u0026#39;1\u0026#39;: return \u0026#39;1\u0026#39; return \u0026#39;0\u0026#39; def f2(a, b): if a == \u0026#39;0\u0026#39;: if b == \u0026#39;0\u0026#39;: return \u0026#39;0\u0026#39; return \u0026#39;1\u0026#39; def f3(a): if a == \u0026#39;1\u0026#39;: return \u0026#39;0\u0026#39; if a == \u0026#39;0\u0026#39;: return \u0026#39;1\u0026#39;   代入f1-f3得到：(a \u0026amp; ~b) | (~a \u0026amp; b)，emm，就是xor，在数电中的基础逻辑语句只有三个，异或虽然在python中是有^这个符号代替的，但实际原理就是题目中的那样进行逻辑操作：\n1 2  def f4(a, b): return f2(f1(a, f3(b)), f1(f3(a), b))   简化：\n1 2  def f4(a, b): return a ^ b   f5同样代入：\n1 2 3 4  def f5(x, y, z): s = f4(f4(x, y), z) c = f2(f1(x, y), f1(z, f2(x, y))) return (s, c)   得到，没看懂在干啥：\n1 2 3 4  def f5(x, y, z): s = x ^ y ^ z c = (x \u0026amp; y) | (z \u0026amp; (x | y)) return (s, c)   找到f6调用的位置：\n1 2 3 4 5 6 7 8 9 10 11 12  def f6(a, b): ans = \u0026#39;\u0026#39; z = \u0026#39;0\u0026#39; a = a[::-1] b = b[::-1] for i in range(32): ans += f5(a[i], b[i], z)[0] z = f5(a[i], b[i], z)[1] return ans[::-1]   测试一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def f6(a, b): ans = \u0026#39;\u0026#39; z = \u0026#39;0\u0026#39; a = a[::-1] b = b[::-1] for i in range(32): tmp = f5(a[i], b[i], z) print(tmp) ans += tmp[0] z = tmp[1] return ans[::-1] s = \u0026#39;00000000000000000000000000000001\u0026#39; d = \u0026#39;10011110001101110111100110111001\u0026#39; res = f6(s, d) print(res)   得到res: 10011110001101110111100110111010\n可以发现f6其实就是做了个二进制加法，传入的两个参数为二进制字符串，对于二进制字符串，字符串的高位为数据低位，所以传入之后会先对字符串进行翻转：\n1 2  a = a[::-1] b = b[::-1]   那么f5的三次异或就可以理解了，最开始z=0，然后传入的x=1, y=1，s = x ^ y ^ z = 0，然后第二个c是用来检测是否产生进位，明显0b01 + 0b01 = 0b10，会产生进位，所以c = 1，然后将进位值给到z，代入下一轮循环，最终生成\nf7，f8都是传入一个二进制字符串，然后传入一个n，很明显，f7就是左移，f8就是右移，n为位数\n1 2 3 4 5  def f7(a, n): return a[n:] + \u0026#39;0\u0026#39; * n def f8(a, n): return n * \u0026#39;0\u0026#39; + a[:-n]   f9逐位异或，最终就是整体异或：\n1 2 3 4 5 6  def f9(a, b): ans = \u0026#39;\u0026#39; for i in range(32): ans += f4(a[i], b[i]) return ans   加密代码分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  def f10(v0, v1, k0, k1, k2, k3): s = \u0026#39;00000000000000000000000000000000\u0026#39; d = \u0026#39;10011110001101110111100110111001\u0026#39; for i in range(32): s = f6(s, d) v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1))) v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3))) return v0 + v1 k0 = \u0026#39;0100010001000101\u0026#39;.zfill(32) k1 = \u0026#39;0100000101000100\u0026#39;.zfill(32) k2 = \u0026#39;0100001001000101\u0026#39;.zfill(32) k3 = \u0026#39;0100010101000110\u0026#39;.zfill(32) flag = input(\u0026#39;please input flag:\u0026#39;) if flag[0:7] != \u0026#39;SUSCTF{\u0026#39; or flag[(-1)] != \u0026#39;}\u0026#39;: print(\u0026#39;Error!!!The formate of flag is SUSCTF{XXX}\u0026#39;) time.sleep(5) exit(0) flagstr = flag[7:-1] if len(flagstr) != 24: print(\u0026#39;Error!!!The length of flag 24\u0026#39;) time.sleep(5) exit(0) else: res = \u0026#39;\u0026#39; for i in range(0, len(flagstr), 8): v0 = flagstr[i:i + 4] v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[(i + 1)]))[2:].zfill(8) + bin(ord(flagstr[(i + 2)]))[2:].zfill(8) + bin(ord(flagstr[(i + 3)]))[2:].zfill(8) v1 = bin(ord(flagstr[(i + 4)]))[2:].zfill(8) + bin(ord(flagstr[(i + 5)]))[2:].zfill(8) + bin(ord(flagstr[(i + 6)]))[2:].zfill(8) + bin(ord(flagstr[(i + 7)]))[2:].zfill(8) res += f10(v0, v1, k0, k1, k2, k3) if res == \u0026#39;001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111\u0026#39;: print(\u0026#39;True\u0026#39;) else: print(\u0026#39;False\u0026#39;)   首先是限制了flag格式为SUSCTF{xxx}，flag正文内容为24字节，进行三次循环，每次循环取8个字节，分成前后4个字节，然后拼接成32位的字符串，bin(ord(flagstr[i]))[2:].zfill(8)字符转二进制字符串\n1 2 3 4 5  for i in range(0, len(flagstr), 8): v0 = flagstr[i:i + 4] v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[(i + 1)]))[2:].zfill(8) + bin(ord(flagstr[(i + 2)]))[2:].zfill(8) + bin(ord(flagstr[(i + 3)]))[2:].zfill(8) v1 = bin(ord(flagstr[(i + 4)]))[2:].zfill(8) + bin(ord(flagstr[(i + 5)]))[2:].zfill(8) + bin(ord(flagstr[(i + 6)]))[2:].zfill(8) + bin(ord(flagstr[(i + 7)]))[2:].zfill(8) res += f10(v0, v1, k0, k1, k2, k3)   处理完字符串之后通过f10进行处理，这里传入了k0-k3应该是4个key：\n1 2 3 4  k0 = \u0026#39;0100010001000101\u0026#39;.zfill(32) k1 = \u0026#39;0100000101000100\u0026#39;.zfill(32) k2 = \u0026#39;0100001001000101\u0026#39;.zfill(32) k3 = \u0026#39;0100010101000110\u0026#39;.zfill(32)   转成16进制看看：\n1 2 3 4 5 6 7  def bin2hex(k): return hex(int(k, 2)) k0 = bin2hex(k0) k1 = bin2hex(k1) k2 = bin2hex(k2) k3 = bin2hex(k3)   将d也转成16进制，发现TEA算法特征\nf10代入功能代码进行简化，可以得到f10就是TEA算法的加密过程：\n1 2 3 4 5 6 7 8 9  def f10(v0, v1, k0, k1, k2, k3): s = \u0026#39;00000000000000000000000000000000\u0026#39; d = \u0026#39;10011110001101110111100110111001\u0026#39; # 0x9e3779b9 for i in range(32): s = s + d v0 = v0 + ((v1 \u0026lt;\u0026lt; 4) + k0) ^ (v1 + s) ^ ((v1 \u0026gt;\u0026gt; 5) + k1)\tv1 = v1 + ((v0 \u0026lt;\u0026lt; 4) + k2) ^ (v0 + s) ^ ((v0 \u0026gt;\u0026gt; 5) + k3) return v0 + v1   测试：\n1 2 3 4 5 6 7 8 9  flagstr = \u0026#39;abcdefgh\u0026#39; v0 = bin(ord(flagstr[0]))[2:].zfill(8) + bin(ord(flagstr[1]))[2:].zfill(8) + bin(ord(flagstr[2]))[2:].zfill(8) + bin(ord(flagstr[3]))[2:].zfill(8) v1 = bin(ord(flagstr[4]))[2:].zfill(8) + bin(ord(flagstr[5]))[2:].zfill(8) + bin(ord(flagstr[6]))[2:].zfill(8) + bin(ord(flagstr[7]))[2:].zfill(8) k0 = \u0026#39;0100010001000101\u0026#39;.zfill(32) k1 = \u0026#39;0100000101000100\u0026#39;.zfill(32) k2 = \u0026#39;0100001001000101\u0026#39;.zfill(32) k3 = \u0026#39;0100010101000110\u0026#39;.zfill(32) print(f10(v0, v1, k0, k1, k2, k3))   每次循环的结果是二进制字符串的拼接：\n每次循环取flag的8个字节，加密结果互不影响，所以最终拼接会得到192个字节的长度，与res进行比较：\n那么只需要将res按64字节分成三份，分别进行解密即可得到真正的flag\nExp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  from ctypes import * class DigitalCircuits(): def __init__(self) : self.k0 = int(\u0026#39;0100010001000101\u0026#39;, 2) self.k1 = int(\u0026#39;0100000101000100\u0026#39;, 2) self.k2 = int(\u0026#39;0100001001000101\u0026#39;, 2) self.k3 = int(\u0026#39;0100010101000110\u0026#39;, 2) self.res = \u0026#39;001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111\u0026#39; def decrypt(self, v): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x9e3779b9 total = c_uint32(delta * 32) for i in range(32): v1.value -= ((v0.value\u0026lt;\u0026lt;4) + self.k2) ^ (v0.value + total.value) ^ ((v0.value\u0026gt;\u0026gt;5) + self.k3) v0.value -= ((v1.value\u0026lt;\u0026lt;4) + self.k0) ^ (v1.value + total.value) ^ ((v1.value\u0026gt;\u0026gt;5) + self.k1) total.value -= delta return hex(v0.value)[2:] + hex(v1.value)[2:] def bin2hex(self, a): return hex(int(a, 2)) def bin2int(self, a): return int(a, 2) def split_flag(self): flag = [] for i in range(3): flag.append(self.bin2int(self.res[i*64:(i+1)*64])) return flag def run(self): flag_enc = self.split_flag() flag = \u0026#39;\u0026#39; for flag_seg in flag_enc: tmp = self.decrypt([flag_seg \u0026gt;\u0026gt; 32, flag_seg \u0026amp; 0xffffffff]) for i in range(0, len(tmp), 2): flag += chr(int(tmp[i:i+2], 16)) print(\u0026#39;SUSCTF{\u0026#39;+ flag + \u0026#39;}\u0026#39;) dc = DigitalCircuits() dc.run()   得到flag：\n1  SUSCTF{XBvfaEdQvbcrxPBh8AOcJ6gA}   总结 考点\n pyinstaller打包exe文件的反编译 基础TEA算法加解密   比起以往的XCTF联赛逆向，这次的题目感觉像是入门题了，整体难度不高，该题的难点在于将TEA算法用二进制的形式进行描述，但只要将功能代码分析代入简化，便能轻松秒杀\n ","date":"2022-03-04T00:00:00Z","permalink":"https://YuSec2021.github.io/p/ctf/susctf2022_digitalcircuits/","title":"Reverse-DigitalCircuits"},{"content":"[UTCTF2020]babymips 0x00 MIPS的指令：\nIDA可以直接反编译出MIPS的伪代码，所以我们直接看伪代码即可，可以看到是C++语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // $v0  char v5[24]; // [sp+18h] [+18h] BYREF  char v6[24]; // [sp+30h] [+30h] BYREF  char v7[84]; // [sp+48h] [+48h] BYREF  std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v5, argv, envp); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;enter the flag\u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v3, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); std::operator\u0026gt;\u0026gt;\u0026lt;char\u0026gt;(\u0026amp;std::cin, v5); memcpy(v7, \u0026amp;unk_4015F4, sizeof(v7)); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v6, v5); sub_401164(v7, v6); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v6); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v5); return 0; }   关键函数：sub_401164传入两个参数，一个是v7，将unk_4015F4复制，一个是v6，就是输入的flag\n导出unk_4015F4:\n1 2 3 4 5 6 7 8 9 10 11 12 13  unsigned char ida_chars[] = { 0x62, 0x6C, 0x7F, 0x76, 0x7A, 0x7B, 0x66, 0x73, 0x76, 0x50, 0x52, 0x7D, 0x40, 0x54, 0x55, 0x79, 0x40, 0x49, 0x47, 0x4D, 0x74, 0x19, 0x7B, 0x6A, 0x42, 0x0A, 0x4F, 0x52, 0x7D, 0x69, 0x4F, 0x53, 0x0C, 0x64, 0x10, 0x0F, 0x1E, 0x4A, 0x67, 0x03, 0x7C, 0x67, 0x02, 0x6A, 0x31, 0x67, 0x61, 0x37, 0x7A, 0x62, 0x2C, 0x2C, 0x0F, 0x6E, 0x17, 0x00, 0x16, 0x0F, 0x16, 0x0A, 0x6D, 0x62, 0x73, 0x25, 0x39, 0x76, 0x2E, 0x1C, 0x63, 0x78, 0x2B, 0x74, 0x32, 0x16, 0x20, 0x22, 0x44, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };   sub_401164，整体逻辑很简单，显示判断a2的size是否为0x4E，是则进入for循环，对a2挨个字符进行异或与a1相比，最终都相等则输出correct：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int __fastcall sub_401164(int a1, int a2) { int v2; // $v0  int result; // $v0  int v4; // $v0  unsigned int i; // [sp+1Ch] [+1Ch]  if ( std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(a2) != 0x4E ) { LABEL_2: v2 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;incorrect\u0026#34;); result = std::ostream::operator\u0026lt;\u0026lt;(v2, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } else { for ( i = 0; i \u0026lt; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(a2); ++i ) { if ( (*(char *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[](a2, i) ^ (i + 23)) != *(char *)(a1 + i) ) goto LABEL_2; } v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;correct!\u0026#34;); result = std::ostream::operator\u0026lt;\u0026lt;(v4, \u0026amp;std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); } return result; }   根据以上即可写出exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026lt;iostream\u0026gt;using namespace std; int main() { unsigned char res[84] = { 0 }; unsigned char ida_chars[] = { 0x62, 0x6C, 0x7F, 0x76, 0x7A, 0x7B, 0x66, 0x73, 0x76, 0x50, 0x52, 0x7D, 0x40, 0x54, 0x55, 0x79, 0x40, 0x49, 0x47, 0x4D, 0x74, 0x19, 0x7B, 0x6A, 0x42, 0x0A, 0x4F, 0x52, 0x7D, 0x69, 0x4F, 0x53, 0x0C, 0x64, 0x10, 0x0F, 0x1E, 0x4A, 0x67, 0x03, 0x7C, 0x67, 0x02, 0x6A, 0x31, 0x67, 0x61, 0x37, 0x7A, 0x62, 0x2C, 0x2C, 0x0F, 0x6E, 0x17, 0x00, 0x16, 0x0F, 0x16, 0x0A, 0x6D, 0x62, 0x73, 0x25, 0x39, 0x76, 0x2E, 0x1C, 0x63, 0x78, 0x2B, 0x74, 0x32, 0x16, 0x20, 0x22, 0x44, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; for (int i = 0; i \u0026lt; 0x4E; i++) { res[i] = ida_chars[i] ^ (i + 23); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; }   得到：\n1  utflag{mips_cpp_gang_5VDm:~`N]ze;\\)5%vZ=C\u0026#39;C(r#$q=*efD\u0026#34;ZNY_GX\u0026gt;6\u0026amp;sn.wF8$v*mvA@\u0026#39;}   到这里解题就结束了，接下来就是关于MIPS指令的学习\n0x01 MIPS指令 首先需要知道MIPS和x86指令最本质的区别就是，MIPS属于RISC（精简指令集），x86属于CISC（复杂指令集）。\n精简指令集与复杂指令集的区别就是指令的数量，精简指令集是以最大化程度减少指令的数量，那么相应的，某些功能如果通过精简指令集进行表达，则需要多条指令结合才能达到目的。而复杂指令集相反，增加指令的类型和数量，减少某些功能执行指令的数量。可以说前者是牺牲时间换空间，后者则是牺牲空间换时间，在某些简单操作上，精简指令集是比较占优势的，而对于复杂操作，复杂指令集的效率往往会更高，目前我们常用的Linux、Windows系统都是属于x86或者arm架构的复杂指令集。\nMIPS，全称为Microcompute without InterLocked Pipeline Stages，中文翻译为无互锁流水级的微处理器\nMIPS包含32个通用寄存器（$0-$31）:\n   编号 助记符 用法     0 zero 不管传入什么数据，该寄存器的值永远都为0   1 at 用作汇编器的暂时变量   2-3 v0, v1 子函数调用返回结果   4-7 a0-a3 子函数调用的参数   8-15 t0-t7 暂时变量，子函数调用时不需要保存与恢复   24-25 t8-t9 暂时变量，子函数调用时不需要保存与恢复   16-23 s0-s7 子函数寄存器变量，在返回之前子函数必须保存和恢复使用过的变量，   26-27 k0, k1 通常被中断或异常处理程序使用作为保存一些系统参数   28 gp 全局指针，一些运行系统维护这个指针来更方便的存取static和extern变量   29 sp 堆栈指针   30 s8/fp 第9个寄存器变量/框架指针   31 ra 子函数的返回地址    MIPS三种指令格式：\n R格式 Register Format 所有其他 I格式 Immediate Format 用于有立即数的指令，lw,sw, J格式 Jump Format 无条件跳转j，并连接jal  R指令\n0x02 实例 根据功能可以分为五类：\n1.算数运算：\n1 2 3 4 5 6 7 8 9 10  move $t5, $t1 // $t5 = $t1; add $t0, $t1, // $t2 $t0 = $t1 + $t2; 带符号数相加 sub $t0, $t1, // $t2 $t0 = $t1 - $t2; 带符号数相减 addi $t0, $t1, 5 // $t0 = $t1 + 5; addu $t0, $t1, $t2 // $t0 = $t1 + $t2; 无符号数相加 subu $t0, $t1, $t2 // $t0 = $t1 - $t2; 无符号数相减 mult $t3, $t4 // $t3 * $t4, 把64-Bits 的积，存储到Lo，Hi中。即： (Hi, Lo) = $t3 * $t4; div $t5, $t6 // Lo = $t5 / $t6 (Lo为商的整数部分);　Hi = $t5 mod $t6 (Hi为余数) mfhi $t0 // $t0 = Hi mflo $t1 // $t1 = Lo   2.分支跳转：\n1 2 3 4 5 6 7  b target 无条件的分支跳转，将跳转到target 标签处 beq $t0, $t1, target // 如果 $t0 == $t1, 则跳转到target 标签处 blt $t0, $t1, target // 如果 $t0 \u0026lt; $t1, 则跳转到target 标签处 ble $t0, $t1, target // 如果 $t0 \u0026lt;=$t1, 则跳转到target 标签处 bgt $t0, $t1, target // 如果 $t0 \u0026gt; $t1, 则跳转到target 标签处 bge $t0, $t1, target // 如果 $t0 \u0026gt;= $t1, 则跳转到target 标签处 bne $t0, $t1, target // 如果 $t0 != $t1, 则跳转到target 标签处   3.跳转：\n1 2  j target // 无条件的跳转, 将跳转到target 标签处 jr $t3 // 跳转到t3寄存器所指向的地址处（Jump Register）   4.数据加载/存储\n1 2 3 4 5  la $t0, val_1 复制val_1表示的地址到t0寄存器中 注： val_1是个Label lw $t2, ($t0) t0寄存器中的值作为地址，把这个地址起始的Word 复制到t2 中 lw $t2, 4($t0) t0寄存器中的值作为地址， 把这个地址再加上偏移量4后 所起始的Word 复制到t2 中 sw $t2, ($t0) 把t2寄存器中值（1 Word），存储到t0的值所指向的RAM中 sw $t2, -12($t0) 把t2寄存器中值（1 Word），存储到t0的值再减去偏移量12, 所指向的RAM 中   5.子函数调用\n1 2 3 4  jal sub_routine_label 执行步骤： a. 复制当前的PC（Program Counter）到$ra寄存器中。 因为当前的PC 值就是子函数执行完毕后的返回 地址。 b. 程序跳转到子程序标签sub_routine_label处   根据以上实例大概可以了解到，对于存在立即数的指令，指令的助记符必须加上i，例如addi $t0 $t1 5、subi $t0 $t1 5，对于无符号数操作，与x86中类似，在助记符后加u即可，例如addu $t0 $t1，如果同时存在，则加上iu，例如 subiu $t0 $t1 5\n0x03 实例练习 在该题中，首先根据graph流程图，找到循环的位置：\n在进循环前执行：sw $zero, 0x28+var_C($fp)，在反编译中，进循环前第一步就是int i = 0，由于$zero寄存器中的值永远为0，所以可以知道该指令就是对内存的赋值，对于0x28+var_c($fp)中的值进行赋值，那么该变量就是此时的i，可以发现sw就是从左往右赋值。在每次循环结束时，i++，根据关键字寻找可以发现，跳转前执行以下指令：\n1 2 3 4  lw $v0, 0x28+var_C($fp) addiu $v0, 1 sw $v0, 0x28+var_C($fp) b loc_4011FC   与sw相反的就是lw，从右往左赋值，将临时变量i存入寄存器v0中，然后将v0的值加1，通过sw将值存回i中。\n对于lw称为数据加载，将数据从内存加载到寄存器中，而sw称为数据存储，将数据从寄存器存储到内存中，然后调用分支指令b跳转到判断的位置：\n1 2 3 4 5 6 7 8 9 10 11  lw $a0, 0x28+arg_4($fp) la $v0, _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4sizeEv # std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(void) move $t9, $v0 jalr $t9 ; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(void) # std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(void) nop lw $gp, 0x28+var_18($fp) move $v1, $v0 lw $v0, 0x28+var_C($fp) sltu $v0, $v1 andi $v0, 0xFF beqz $v0, loc_4012E0   首先加载地址到a0寄存器中，通过之前的了解我们知道a0-a3都是子函数的参数，所以继续往下，la应该就是将子函数地址给到v0寄存器，然后赋值到t9寄存器中，通过jalr指令进行子函数调用，此时a0作为参数，其实就是输入的flag的地址，调用完之后，将strlen的结果加载到v0寄存器中，往下就是将v0的结果复制到v1，然后取i加载到v0，执行sltu对v0和v1进行比较，根据前面的学习，sltu无符号数操作，所以此时sltu $v0, $v1的含义是，if $v0 \u0026lt; $v1, $v0 = 1, else $v0 = 0，往下的beqz就是如果v0=0则跳转到loc_4012E0的位置继续执行，该位置就是提示成功的位置了：\n往下便如法炮制了，不再做深入了解，通过本题大概学习了MIPS的指令格式以及其与x86架构的一些区别，后续如果遇到其他相关题目，再做深入的学习\n参考文献 [1]https://blog.csdn.net/qq_41191281/article/details/85933985\n[2]https://blog.csdn.net/ben_chong/article/details/51794093\n","date":"2022-03-03T00:00:00Z","permalink":"https://YuSec2021.github.io/p/ctf/utctf2020_babymips/","title":"babymips"},{"content":"Windows 内核 0x01 双机调试配置 VMware + WinDBG\n删除Printer，添加串行端口Serial Port：\nUse named pipe： \\\\.\\pipe\\com1\n启动Windows XP，找到C:\\boot.ini，添加一行：\t\n实体机中安装WinDBG preview：\n文件-\u0026gt; Attack To Kernel:\n成功连接：\n未完待续。。。\n","date":"2022-03-02T14:39:02+08:00","permalink":"https://YuSec2021.github.io/p/tech/windows_kernel/","title":"Windows Kernel基础"},{"content":"[RCTF2019]DontEatMe 去反调试 EXE文件，IDA反编译：\n通过srand固定时间戳生成伪随机数，然后在调用rand之前，有一段反调试：\n拿到Ntdll的模块句柄，从句柄中查找ZwSetInformationThread的地址，然后调用这个函数去检查当前线程是否处于Debug模式下：\n1 2 3 4  v3 = GetModuleHandleA(\u0026#34;Ntdll\u0026#34;); ZwSetInformationThread = GetProcAddress(v3, \u0026#34;ZwSetInformationThread\u0026#34;); v5 = GetCurrentThread(); ((void (__stdcall *)(HANDLE, int, _DWORD, _DWORD))ZwSetInformationThread)(v5, 17, 0, 0);   关于ZwSetInformationThread的类型：\n1 2 3 4 5 6  typedef NTSTATUS(NTAPI* pZwSetInformationThread)( IN HANDLE ThreadHandle,\t// 线程对象句柄 \tIN THREAD_INFO_CLASS ThreadInformaitonClass,\t// 线程信息类型 \tIN PVOID ThreadInformation,\t// 线程信息指针 \tIN ULONG ThreadInformationLength\t// 线程信息大小 );   线程信息类型为枚举类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  typedef enum _THREADINFOCLASS { ThreadBasicInformation, ThreadTimes, ThreadPriority, ThreadBasePriority, ThreadAffinityMask, ThreadImpersonationToken, ThreadDescriptorTableEntry, ThreadEnableAlignmentFaultFixup, ThreadEventPair, ThreadQuerySetWin32StartAddress, ThreadZeroTlsCell, ThreadPerformanceCount, ThreadAmILastThread, ThreadIdealProcessor, ThreadPriorityBoost, ThreadSetTlsArrayAddress, ThreadIsIoPending, ThreadHideFromDebugger }THREAD_INFO_CLASS;   该程序中载入的参数就是ThreadHideFromDebugger，此时如果检测到处理Debugger模式就会将该线程强制分离出调试器，该函数与IsDebuggerPresent类似都是用于反调试的\n载入调试模式后在该call之后程序会因为Debug退出，为了不影响程序后续的正常运行，这里过反调试尽量不要有大的修改，该函数的功能根据的ThreadInformaitonClass这个参数，将该参数的值设为ThreadHideFromDebugger时便是处于反调试状态，那么过反调试只需要将ThreadHideFromDebugger 改成 ThreadBasicInformation即可，体现在汇编指令上就是将push 0x11改成push 0x00:\nps: 这里发现如果有其他的修改，可能会导致堆栈存在问题，影响后面strlen的结果，所以在Patch时以最小字节修改为最佳方式，针对该反调试的修改只修改了一个字节，即压入的参数值，对整体的程序无影响，也不影响堆栈的平衡\n在前面的动态分析中可以发现call esi指向的是NtSetInformationThread的地址而不是ZwSetInformationThread的地址，这里再深入了解一下Zw和Nt函数的区别，首先关于这两个前缀的函数在Ring3和Ring0都是有的，在Ring3中由ntdll.dll导出，可以发现两个函数指向同一个函数地址，从这里可以得到在Ring3情况下两个函数没有区别：\n在用户态下，Zw和Nt函数的EntryPoint相同，可以理解为是同一个函数，而我们通过x32dbg或者OllyDBG实际上都是用户态的调试，所以在调试中显示的调用的这两个函数实际上就是同一个函数，两种函数在内核态的系统调用下才会存在区别，具体参考文章https://www.cnblogs.com/seamanj/p/3181151.html，本文不再展开\n回到该题，main函数拢共200+行代码，中间一部份都是些数据处理，猜测可能存在算法，FindCrypt查看，发现存在BlowFish算法：\nBLOWFISH blowfish加密算法是一种对称的分组加密算法，对Plaintext进行分组，每组长度为64bit，而该加密的密钥为变长密钥，32bit-448bit都可以当作密钥进行加解密处理\n密钥可以定义为Key数组，该数组的长度为[1, 14]\n存在两个数组pBox和sBox，pBox为18个32位子密钥组成，sBox为4*256个32位子密钥组成，一般情况下，是用Π的小数点的16进制：\nBlowFish加密过程：\n 传入明文和密钥K，密钥K的长度为32bit-448bit，密钥K数组的单位为32bit，所以得到K = [K1, K2, ... , Kn]，其中1≤n≤14 初始化子密钥，子密钥分为1个pBox和4个sBox，pBox的长度为18，sBox的长度为256，一般情况下，该子密钥的初始化为Π的16进制 子密钥预处理pBox：这里密钥数组K的长度最大只有14，所以存在轮换使用密钥的情况，假设密钥数组K的长度为14，首先是pBox与密钥数组K进行异或：  pBox[0] ^ K[0] pBox[1] ^ K[1] \u0026hellip; pBox[13] ^ K[13] pBox[14] ^ K[0]   pBox变换：产生一个64bit全0的数据，然后调用BlowFish的主加密函数进行加密，得到一个64bit的数据替换pBox的数据，总共进行9轮，得到一个新的pBox sBox变换：此时沿用pBox中产生的leftpart和rightpart，再次通过BlowFish进行主加密函数进行加密，每次将处理后的leftpart和rightpart进行替换，替换得到新的sBox Plaintext加密：首先是对明文进行填充，若不足8个字节则填充至8个字节，填充为8的整数倍，然后分为前4字节与后4字节传入主加密函数进行加密，在主加密函数中进行加密得到最终的密文  主加密函数，总共为8轮加密，每轮都会从pBox中拿取64bit的数据分成2*32bit异或给leftpart和rightpart，然后再分别异或从sBox中查表得到的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  void BF_Fn(ULONG\u0026amp; leftPart, ULONG\u0026amp; rightPart) { for (int i = 0; i \u0026lt; 16; i += 2) { leftPart ^= p_box[i]; rightPart ^= SearchTable(leftPart); rightPart ^= p_box[i + 1]; leftPart ^= SearchTable(rightPart); } leftPart ^= p_box[16]; rightPart ^= p_box[17]; //swap \tULONG temp = leftPart; leftPart = rightPart; rightPart = temp; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  unsigned DWORD pBox[18] = { 0x243F6A88L, 0x85A308D3L, 0x13198A2EL, 0x03707344L, 0xA4093822L, 0x299F31D0L, 0x082EFA98L, 0xEC4E6C89L, 0x452821E6L, 0x38D01377L, 0xBE5466CFL, 0x34E90C6CL, 0xC0AC29B7L, 0xC97C50DDL, 0x3F84D5B5L, 0xB5470917L, 0x9216D5D9L, 0x8979FB1BL }; unsigned DWORD sBox[4][256] = { { 0xD1310BA6L, 0x98DFB5ACL, 0x2FFD72DBL, 0xD01ADFB7L, 0xB8E1AFEDL, 0x6A267E96L, 0xBA7C9045L, 0xF12C7F99L, 0x24A19947L, 0xB3916CF7L, 0x0801F2E2L, 0x858EFC16L, 0x636920D8L, 0x71574E69L, 0xA458FEA3L, 0xF4933D7EL, ...... 0x85CBFE4EL, 0x8AE88DD8L, 0x7AAAF9B0L, 0x4CF9AA7EL, 0x1948C25CL, 0x02FB8A8CL, 0x01C36AE4L, 0xD6EBE1F9L, 0x90D4F869L, 0xA65CDEA0L, 0x3F09252DL, 0xC208E69FL, 0xB74E6132L, 0xCE77E25BL, 0x578FDFE3L, 0x3AC372E6L } }   BlowFish 解密：\n根据Paul Kocher的源码，可以发现在循环处理中是逆序进行处理，逆序异或pBox，从pBox[17] - pBox[2]，对leftpart进行异或，出循环后对rightpart异或pBox[1]，leftpart异或pBox[0]，整体流程跟加密一样，只是pBox的顺序不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #define N 16 typedef struct { unsigned long P[16 + 2]; unsigned long S[4][256]; } BLOWFISH_CTX; void Blowfish_Decrypt(BLOWFISH_CTX *ctx, unsigned long *xl, unsigned long *xr){ unsigned long Xl; unsigned long Xr; unsigned long temp; short i; Xl = *xl; Xr = *xr; for (i = N + 1; i \u0026gt; 1; --i) { Xl = Xl ^ ctx-\u0026gt;P[i]; Xr = F(ctx, Xl) ^ Xr; /* Exchange Xl and Xr */ temp = Xl; Xl = Xr; Xr = temp; } /* Exchange Xl and Xr */ temp = Xl; Xl = Xr; Xr = temp; Xr = Xr ^ ctx-\u0026gt;P[1]; Xl = Xl ^ ctx-\u0026gt;P[0]; *xl = Xl; *xr = Xr; }   BlowFish初始化 关于BLOWFISH的定位，发现在sub_401090中进行调用，但是该函数调用时并未传入flag相关的内容，所以猜测该函数应该不是对flag进行加密，通过前面了解到的BLOWFISH的特性，该函数应该是对pbox和sbox进行预处理\n在预处理之前，发现存在srand和rand函数，但是该srand指定了时间戳，所以此时应该是伪随机数，将rand生成的数低8位存放到byte_4057A8中，通过测试可以发现，每次生成的数是相同的，顺序也是相同的：\n只取低8位，所以最终得到：a1 18 2c 3a 23 5f 33 cd\npBox的地址-this指针的地址：\n在循环前发现对刚刚srand生成的值进行了覆盖，得到00 0F 1A 01 35 3A 3B 20：\n循环为18次，pBox进行异或，说明该位置就是对pBox的预处理，那么key就是覆盖后的值：\n异或得到：\n进入401000，pBox异或之后的值与eax继续异或：\n根据动态调试可以发现v3最开始指向的就是pBox的首地址，往下对pBox查表之后进行异或：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int *__usercall sub_401000@\u0026lt;eax\u0026gt;(int *a1@\u0026lt;edx\u0026gt;, _DWORD *pBox@\u0026lt;ecx\u0026gt;, int *a3) { _DWORD *v3; // edi  int v4; // eax  unsigned int v5; // eax  int v6; // edx  bool v7; // zf  int v8; // ecx  int *result; // eax  int v11; // [esp+14h] [ebp-8h]  int v12; // [esp+18h] [ebp-4h]  v11 = 16; v3 = pBox; v4 = *a1; v12 = *a3; do { v5 = *v3++ ^ v4; v6 = v5; v4 = v12 ^ (pBox[(unsigned __int8)v5 + 0x312] + (pBox[BYTE1(v5) + 0x212] ^ (pBox[BYTE2(v5) + 0x112] + pBox[HIBYTE(v5) + 0x12]))); v7 = v11-- == 1; v12 = v6; } while ( !v7 ); *a1 = v6 ^ pBox[17]; v8 = v4 ^ pBox[16]; result = a3; *a3 = v8; return result; }   C实现的blowfish算法在searchTable查表是通过sBox查表的，根据内存分布，可以发现pBox和sBox是连续的，该题中反编译的结果是从pBox开始查，但其偏移已经添加了0x12，所以跟从sBox查表的结果相同：\n1 2 3 4 5 6  // 从sBox开始查表的反编译结果 int __cdecl searchTable(unsigned int a1) { __CheckForDebuggerJustMyCode(\u0026amp;unk_41D0A3); return sBox[(unsigned __int8)a1 + 0x300] + (sBox[BYTE1(a1) + 0x200] ^ (sBox[BYTE2(a1) + 0x100] + sBox[HIBYTE(a1)])); }   通过对比源码可以发现sub_401000就是BlowFish下的轮函数，回到sub_401090，可以判断该函数就是blowFishInit：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  do // 变换pBox { BF_FN(\u0026amp;round, (_DWORD *)this, (int *)\u0026amp;v17); *(_DWORD *)(this + 4 * v10) = round; *(_DWORD *)(this + 4 * v10 + 4) = v17; v10 += 2; } while ( v10 \u0026lt; 18 ); v11 = (int **)(this + 76); v16 = 4; do // 变换sBox { v12 = 128; do { BF_FN(\u0026amp;round, (_DWORD *)this, (int *)\u0026amp;v17); *(v11 - 1) = (int *)round; result = v17; *v11 = v17; v11 += 2; --v12; } while ( v12 ); --v16; } while ( v16 );   BlowFish解密 往下取flag，先\u0026amp;7，根据规律可以发现\u0026amp;7就是判断字符串的长度是否被8整除，如果不被整除则在后面格式化输入时进行填充，往下格式化字符串输入，转成16进制，根据这个可以知道输入的flag范围0-9A-Fa-f\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  flag_len = strlen(flag); v9 = flag_len; v49 = flag_len; if ( (flag_len \u0026amp; 7) != 0 ) { v9 = 8 * (flag_len \u0026gt;\u0026gt; 3) + 8; v49 = v9; } v54 = (char *)calloc(v9, 1u); res_0 = (unsigned __int8 *)calloc(v9 / 2, 1u); idx_0 = 0; v51 = res_0; if ( v9 / 2 \u0026gt; 0 ) { v12 = flag; do { sscanf(v12, \u0026#34;%02x\u0026#34;, idx_0 + (_BYTE)res_0); res_0 = v51; ++idx_0; v12 += 2; } while ( idx_0 \u0026lt; v9 / 2 ); v9 = v49; }   在进入第一个do-while之前会将指针指向第三个字节，然后可以看到第一个do-while循环中，取了8个字节分为上下两组进行或运算和移位运算，得到pre_dword和suf_dword，v13[1] | ((*v13 | ((*(v13 - 1) | (*(v13 - 2) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8)可以发现其实就是以dword形式输出：例如0x12,0x34, 0x56,0x78 -\u0026gt; 0x12345678，回到BLOWFISH，注意他的plain是以64位为一组，每组中又将64位拆分成上32位和下32位，第二个do-while循环中可以看到pre_dword异或v14之后给到suf_dword，而suf_dword进行几步异或之后给到pre_dword ，可以猜测该部分应该是BLOWFISH的加密或者解密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  v50 = 0; v55 = v9 / 16; if ( v9 / 16 \u0026lt;= 0 ) { v26 = v54; } else { v13 = res_0 + 2; v53 = v13; do { v14 = v57; v52 = 16; pre_dword = v13[1] | ((*v13 | ((*(v13 - 1) | (*(v13 - 2) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8); suf_dword = v13[5] | ((v13[4] | ((v13[3] | (v13[2] \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8)) \u0026lt;\u0026lt; 8); do { v17 = *(_DWORD *)v14 ^ pre_dword; v14 -= 4; v18 = v17; pre_dword = suf_dword ^ (*(_DWORD *)\u0026amp;v57[4 * (unsigned __int8)v17 + 3076] + (*(_DWORD *)\u0026amp;v57[4 * BYTE1(v17) + 2052] ^ (*(_DWORD *)\u0026amp;v57[4 * BYTE2(v17) + 1028] + *(_DWORD *)\u0026amp;v57[4 * HIBYTE(v17) + 4]))); v19 = v52-- == 1; suf_dword = v18; } while ( !v19 ); v20 = v18 ^ v56[0]; v21 = calloc(4u, 1u); *v21 = HIBYTE(v20); v21[1] = BYTE2(v20); v21[2] = BYTE1(v20); v21[3] = v20; v22 = v56[1]; *(_DWORD *)\u0026amp;v54[8 * v50] = *(_DWORD *)v21; v23 = pre_dword ^ v22; v24 = calloc(4u, 1u); *v24 = HIBYTE(v23); v24[1] = BYTE2(v23); v25 = v23 \u0026gt;\u0026gt; 8; v24[3] = v23; v26 = v54; v24[2] = v25; *(_DWORD *)\u0026amp;v54[8 * v50 + 4] = *(_DWORD *)v24; v13 = v53 + 8; v53 += 8; ++v50; } while ( v50 \u0026lt; v55 ); }   变量较多，直接动态调试：\n第一次循环异或的是pBox[17]，循环16次并且倒序异或pBox，最后再异或pBox[0]和pBox[1]，确定该部分应该是blowfish的解密：\n解迷宫 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  v58[0] = 0x4D746145746E6F44i64; v27 = _byteswap_ushort(0x6F44u); v28 = _byteswap_ushort(0x746Eu); v29 = _byteswap_ushort(0x6145u); v30 = _byteswap_ushort(0x4D74u); v31 = \u0026amp;byte_40501A; do { *((_WORD *)v31 - 1) ^= v27; *(_WORD *)v31 ^= v28; *((_WORD *)v31 + 1) ^= v29; *((_WORD *)v31 + 2) ^= v30; v31 += 8; } while ( (int)v31 \u0026lt; (int)\u0026amp;unk_40503A ); v32 = dword_4053A8; v33 = (unsigned __int16 *)\u0026amp;unk_405018; do { v34 = *v33; for ( j = 15; j \u0026gt; -1; --j ) { v36 = (v34 \u0026amp; (1 \u0026lt;\u0026lt; j)) \u0026gt;\u0026gt; j; *v32++ = v36; } ++v33; } while ( (int)v33 \u0026lt; (int)\u0026amp;unk_405038 );   首先是对v27-v30进行了字节序的调转：\n通过do-while对byte_405018 - byte_40503A进行了异或处理\n1  ff ff 3f 80 bf bf bf bf 07 bc f7 bd f7 bd 37 bc b7 bf b7 bf 37 80 f7 fb 07 f8 ff ff ff ff ff ff   对异或之后的结果进行移位运算和或运算，得到一个只有0和1的大矩阵：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  00AC53A8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC53B8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC53C8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC53D8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC53E8 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC53F8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC5408 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5418 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5428 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5438 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5448 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5458 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5468 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5478 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5488 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5498 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC54A8 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC54B8 01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC54C8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC54D8 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC54E8 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC54F8 01 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 ................ 00AC5508 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5518 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5528 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5538 01 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 ................ 00AC5548 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5558 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5568 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5578 01 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC5588 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5598 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC55A8 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC55B8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC55C8 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC55D8 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC55E8 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC55F8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5608 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5618 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5628 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC5638 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC5648 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5658 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5668 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5678 01 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5688 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5698 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC56A8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC56B8 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC56C8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00AC56D8 00 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC56E8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC56F8 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5708 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5718 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5728 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5738 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5748 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5758 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5768 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5778 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5788 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................ 00AC5798 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 00 ................   根据switch-case以及前面得到的矩阵得到这部分就是解迷宫了，起点line=10, row=5，终点line=4, row=9\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  v37 = *decrypt_flag; line = 10; step = 0; row = 5; if ( *decrypt_flag ) { v41 = 160; while ( 1 ) { switch ( v37 ) { case \u0026#39;a\u0026#39;: --row; break; case \u0026#39;d\u0026#39;: ++row; break; case \u0026#39;s\u0026#39;: ++line; v41 += 16; break; case \u0026#39;w\u0026#39;: --line; v41 -= 16; break; default: break; } if ( dword_4053A8[v41 + row] == 1 ) break; v37 = decrypt_flag[++step]; if ( !v37 ) { if ( line == 4 \u0026amp;\u0026amp; row == 9 \u0026amp;\u0026amp; step \u0026lt; 17 ) { printf(\u0026#34;Congratulations! Here is your flag: RCTF{%s}\u0026#34;, (char)flag); return 0; } break; } } } printf(\u0026#34;Oh no. Dont eat me!!!!\u0026#34;, v48);   动态调试根据eax*4+AC53A8可以发现这里取值时是先将row和line相加，初始化时line为160，而row为5，d往右走，所以得到160+5+1 = 0xA6，然后再乘4，找值，所以可以发现如果是左右走的话应该是每步加减4，而上下走每步应该是加减64：\n根据生成的矩阵可以发现只在低byte有值，高3个byte都是0，所以可以把多余的0去掉方便找到路线：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  unsigned char ida_chars[] = { 0x90, 0xBB, 0x4B, 0xEE, 0xDE, 0xFA, 0xF2, 0xCB, 0x68, 0xF8, 0x83, 0xD3, 0x96, 0xF8, 0x7A, 0xC8, 0xD8, 0xFB, 0xC3, 0xD1, 0x56, 0xC5, 0xBA, 0x8F, 0x68, 0xBC, 0x8B, 0x91, 0x9E, 0xBA, 0xB2, 0x8B }; short* res = (short*)malloc(16); memset(res, 0, 16); short v27 = _byteswap_ushort(0x6F44u); short v28 = _byteswap_ushort(0x746Eu); short v29 = _byteswap_ushort(0x6145u); short v30 = _byteswap_ushort(0x4D74u); for (int i = 0; i \u0026lt; sizeof(ida_chars) / 8; i++) { short* tmp = (short*)\u0026amp; ida_chars[i * 8]; *(res + i * 4) = *tmp ^ v27; *(res + i * 4 + 1) = *(tmp + 1) ^ v28; *(res + i * 4 + 2) = *(tmp + 2) ^ v29; *(res + i * 4 + 3) = *(tmp + 3) ^ v30; } int* v32 = (int*)malloc(0x400); int* metrix = v32; for (int i = 0; i \u0026lt; 16; i++) { for (int j = 15; j \u0026gt; -1; --j) { *v32++ = (*(res + i) \u0026amp; (1 \u0026lt;\u0026lt; j)) \u0026gt;\u0026gt; j; } } for (int i = 0; i \u0026lt; 0x100; i++) { if (i % 16 == 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%02x \u0026#34;, metrix[i]); }   得到：\n根据起点和终点，并且步数不能超过16步，得到：ddddwwwaaawwwddd\n代入加密算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  ULONG SearchTable(ULONG leftPart) { ULONG value; //查表操作 每一个字节查一次表 然后进行加和异或操作 \tvalue = s_box[0][leftPart \u0026gt;\u0026gt; 24] + s_box[1][(leftPart \u0026gt;\u0026gt; 16) \u0026amp; 0xff]; value ^= s_box[2][(leftPart \u0026gt;\u0026gt; 8) \u0026amp; 0xff]; value += s_box[3][leftPart \u0026amp; 0xff]; return value; } //BlowFish的主加密函数 明文的加密和对密钥的变换都是利用这个 迭代变换16轮 inline void BF_Fn(ULONG\u0026amp; leftPart, ULONG\u0026amp; rightPart) { int i; for (i = 0; i \u0026lt; 16; i += 2) { leftPart ^= p_box[i]; rightPart ^= SearchTable(leftPart); rightPart ^= p_box[i + 1]; leftPart ^= SearchTable(rightPart); } leftPart ^= p_box[16]; rightPart ^= p_box[17]; //最后交换一下 \tULONG temp = leftPart; leftPart = rightPart; rightPart = temp; } //子密钥pBox, sBox预处理 void ExchangeBox(int* key) { ULONG leftPart = 0, rightPart = 0; for (int i = 0; i \u0026lt; 18; i++) {//进行异或 \tint tmp = key[i % 2]; p_box[i] ^= tmp; } leftPart = rightPart = 0;//产生一个64位全0数据 \tfor (int i = 0; i \u0026lt; 18; i += 2) {//变换pBox \tBF_Fn(leftPart, rightPart); p_box[i] = leftPart; p_box[i + 1] = rightPart; } for (int i = 0; i \u0026lt; 4; i++) {//变换sBox \tfor (int j = 0; j \u0026lt; 256; j += 2) {//256 / 2 == 128 \tBF_Fn(leftPart, rightPart); s_box[i][j] = leftPart; s_box[i][j + 1] = rightPart; } } } void BlowFish(int* key, byte* data) { int i; int dataLen = strlen((const char*)data) / (sizeof(ULONG) * 2);//获取data长度 \tbyte* dataCopy = data;//建立一个data副本 方便进行指针偏移 \tULONG leftPart, rightPart; ExchangeBox(key); //至此就可以加密明文了 一次加密2 * 4字节大小 \tfor (i = 0; i \u0026lt; dataLen; i++) { leftPart = _byteswap_ulong(*((ULONG*)dataCopy)); rightPart = _byteswap_ulong(*((ULONG*)dataCopy + 1)); BF_Fn(leftPart, rightPart); *((ULONG*)dataCopy) = _byteswap_ulong(leftPart); *((ULONG*)dataCopy + 1) = _byteswap_ulong(rightPart); dataCopy += sizeof(ULONG) * 2;//指向下一个数据块 \t} for (i = 0; i \u0026lt; strlen((const char*)data); i++) { printf(\u0026#34;%02x\u0026#34;, data[i]); } } int key[] = {0x000F1A01, 0x353A3B20}; byte data[] = \u0026#34;ddddwwwaaawwwddd\u0026#34;; BlowFish(key, data);   得到：db824ef8605c5235b4bbacfa2ff8e087\n校验：\n总结以及参考文章 题目难度不高，整体流程也很简单：输入的flag的作为密文，通过blowfish算法解密得到的一串明文为迷宫的路线，涉及到的内容:\n ZwSetInformationThread反调试技术 BlowFish算法在C语言下实现方式 迷宫Puzzle  blowfish各版本源码：https://www.schneier.com/academic/blowfish/download/\n参考文章：\n[1] Blowfish Cipher 浅析： https://bbs.pediy.com/thread-256209.htm\n[2] BlowFish加解密原理与代码实现： https://www.cnblogs.com/iBinary/p/14883752.html#tid-AwA6xn\n[3] windows常用的反调试技术-静态反调试技术：https://bbs.pediy.com/thread-249572.htm\n[4] blowfish加密算法(c实现)： https://blog.csdn.net/qq_40890756/article/details/89256847\n[5] Zw函数与Nt函数的分别与联系：https://www.cnblogs.com/seamanj/p/3181151.html\n","date":"2022-03-01T00:00:00Z","permalink":"https://YuSec2021.github.io/p/ctf/rctf2019_donteatme/","title":"DontEatMe 详细分析及解题过程"},{"content":"[SWPU2019]easyRE main函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int __cdecl main(int argc, const char **argv, const char **envp) { _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF  _DWORD *v5; // [esp+4h] [ebp-88h]  _DWORD *v6; // [esp+8h] [ebp-84h]  int v7; // [esp+Ch] [ebp-80h]  char v8[108]; // [esp+10h] [ebp-7Ch] BYREF  int v9; // [esp+88h] [ebp-4h]  if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; }   首先调用sub_40EF90进行check：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  BOOL sub_40EF90() { HANDLE v0; // eax  NTSTATUS (__stdcall *NtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG); // [esp+0h] [ebp-14h]  HMODULE hModule; // [esp+4h] [ebp-10h]  int v4; // [esp+Ch] [ebp-8h] BYREF  v4 = 0; hModule = LoadLibraryA(\u0026#34;Ntdll.dll\u0026#34;); NtQueryInformationProcess = (NTSTATUS (__stdcall *)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG))GetProcAddress(hModule, \u0026#34;NtQueryInformationProcess\u0026#34;); v0 = GetCurrentProcess(); NtQueryInformationProcess(v0, ProcessDebugPort, \u0026amp;v4, 4, 0); return v4 != 0; }   搜了一下官方文档，发现ProcessDebugPort就是用来检测程序是否处于调试状态的:\n这里crack很简单，动态调试单步来到这个位置，这里是压入三个参数的，一般就是main函数的入口了：\ncall完EF90之后会有个关键跳，这里jmp实现的话就直接退出程序了，直接nop掉jmp即可：\nPatch完之后重新载入x64dbg，此时就可以正常调试了：\n当然了这个调试状态检测我们是可以绕过的，因为是在检测调试之后再执行真正的代码，所以可以先直接运行程序，然后用附加程序，这时候程序已经运行到输入flag的位置了，附加时已经过了检测函数，所以也可以正常进行调试：\n往下来到sub_401FE0，发现有个EASYRE::vftable虚函数表，然后往下对内存进行赋值，总共20个字节，往下还有个内存复制，也是20个字节：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  _DWORD *__thiscall sub_401FE0(_DWORD *this) { int i; // [esp+4h] [ebp-14h]  *this = \u0026amp;EASYRE::`vftable\u0026#39;; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = 0xEA; *((_BYTE *)this + 54) = 0x58; *((_BYTE *)this + 55) = 0xDE; *((_BYTE *)this + 56) = 0x94; *((_BYTE *)this + 57) = 0xD0; *((_BYTE *)this + 58) = 0x3B; *((_BYTE *)this + 59) = 0xBE; *((_BYTE *)this + 60) = 0x88; *((_BYTE *)this + 61) = 0xD4; *((_BYTE *)this + 62) = 0x32; *((_BYTE *)this + 63) = 0xB6; *((_BYTE *)this + 64) = 0x14; *((_BYTE *)this + 65) = 0x82; *((_BYTE *)this + 66) = 0xB7; *((_BYTE *)this + 67) = 0xAF; *((_BYTE *)this + 68) = 0x14; *((_BYTE *)this + 69) = 0x54; *((_BYTE *)this + 70) = 0x7F; *((_BYTE *)this + 71) = 0xCF; qmemcpy(this + 18, \u0026#34; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#34;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i \u0026lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; }   字符串定位到sub_40F150，传入的flag通过sub_4024B0进行校验，条件成立才能输出Congratulations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  int sub_40F150(int a1, int a2, ...) { int v2; // eax  int v3; // eax  int result; // eax  int v5; // eax  int v6[10]; // [esp+Ch] [ebp-38h] BYREF  int v7; // [esp+40h] [ebp-4h]  va_list va; // [esp+54h] [ebp+10h] BYREF  va_start(va, a2); v7 = 0; v6[0] = 0; v6[1] = 0; v6[2] = 0; v6[3] = 0; v6[4] = 0; v6[5] = 0; v6[6] = 0; v6[7] = 0; v6[8] = 0; v6[9] = 0; v2 = sub_40F5B0(std::cout, \u0026#34;Please input your flag : \u0026#34;); std::ostream::operator\u0026lt;\u0026lt;(v2, sub_40F8F0); sub_40F930(std::cin, flag); if ( sub_4024B0(flag) ) { v3 = sub_40F5B0(std::cout, \u0026amp;unk_4122F0); // Congratulations  std::ostream::operator\u0026lt;\u0026lt;(v3, sub_40F8F0); v7 = -1; sub_4021C0(va); result = 1; } else { v5 = sub_40F5B0(std::cout, \u0026amp;unk_41231C); // I\u0026#39;m sorry  std::ostream::operator\u0026lt;\u0026lt;(v5, sub_40F8F0); v7 = -1; sub_4021C0(va); result = 0; } return result; }   sub_4024B0，虚函数调用的特征：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  BOOL __thiscall sub_4024B0(_DWORD *this, int flag) { BOOL result; // eax  this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) { (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; } return result; }   根据虚表简化得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  BOOL __thiscall sub_4024B0(_DWORD *this, int flag) { BOOL result; // eax  this[2] = flag; result = 0; if ( sub_402500(flag) ) { sub_4026E0(); if ( sub_402A00() ) result = 1; } return result; }   sub_402500 将字符串Ncg复制到v8然后将v8的值逐个异或0x10:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  int __thiscall sub_402500(const char **this) { int v2; // [esp+Ch] [ebp-B0h]  unsigned int v3; // [esp+14h] [ebp-A8h]  int i; // [esp+24h] [ebp-98h]  char v6[56]; // [esp+30h] [ebp-8Ch] BYREF  char v7[20]; // [esp+68h] [ebp-54h] BYREF  char v8[48]; // [esp+7Ch] [ebp-40h] BYREF  int v9; // [esp+B8h] [ebp-4h]  v3 = (unsigned int)\u0026amp;this[2][strlen(this[2])]; strcpy(v8, \u0026#34;Ncg`esdvLkLgk$mL=Lgk$mL=Lgk$mL=Lgk$mL=Lgk$mLm\u0026#34;); sub_4026C0(v6, 0x38u); sub_402B00(); v9 = 0; for ( i = 0; i \u0026lt; 45; ++i ) v8[i] ^= 0x10u; sub_4026C0(v7, 0x14u); sub_402A70(v8, 1); LOBYTE(v9) = 1; v2 = (unsigned __int8)sub_404260(this[2], v3, v6, v7, 0); LOBYTE(v9) = 0; sub_402A50(v7); v9 = -1; sub_4026A0(); return v2; }   得到一个正则表达式：^swpuctf\\\\{\\\\w{4}\\\\-\\\\w{4}\\\\-\\\\w{4}\\\\-\\\\w{4}\\\\-\\\\w{4}\\\\}为flag的格式\n1 2 3 4 5 6 7  s = \u0026#34;Ncg`esdvLkLgk$mL=Lgk$mL=Lgk$mL=Lgk$mL=Lgk$mLm\u0026#34; s2 = [] for i in range(0, len(s)): s2.append(chr(ord(s[i]) ^ 0x10)) print(\u0026#39;\u0026#39;.join(i for i in s2)) # ^swpuctf\\\\{\\\\w{4}\\\\-\\\\w{4}\\\\-\\\\w{4}\\\\-\\\\w{4}\\\\-\\\\w{4}\\\\}   那么可以得到第一个函数就是校验flag的格式，dbg中输入：swpuctf{1234-5678-9012-3456-7890}，此时跳转已经不实现：\nsub_402A00 先看到最后一个函数，需要让if成立，使得result=1，才能最终输出Congratulations\n1 2  if ( sub_402A00() ) result = 1;   1 2 3 4 5 6 7 8 9 10 11  int __thiscall sub_402A00(unsigned __int8 *this) { int i; // [esp+4h] [ebp-4h]  for ( i = 0; i \u0026lt; 40; ++i ) { if ( this[i + 52] != this[i + 12] ) return 0; } return 1; }   this[52]在sub_401FE0中进行了赋值，需要注意i从0开始经过40次循环，回到sub_401FE0的初始化，发现还存在一个字符串： 03\\\u0026quot;3 0 203\\\u0026quot; $，说明还存在一个需要比较的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = 0xEA; *((_BYTE *)this + 54) = 0x58; *((_BYTE *)this + 55) = 0xDE; *((_BYTE *)this + 56) = 0x94; *((_BYTE *)this + 57) = 0xD0; *((_BYTE *)this + 58) = 0x3B; *((_BYTE *)this + 59) = 0xBE; *((_BYTE *)this + 60) = 0x88; *((_BYTE *)this + 61) = 0xD4; *((_BYTE *)this + 62) = 0x32; *((_BYTE *)this + 63) = 0xB6; *((_BYTE *)this + 64) = 0x14; *((_BYTE *)this + 65) = 0x82; *((_BYTE *)this + 66) = 0xB7; *((_BYTE *)this + 67) = 0xAF; *((_BYTE *)this + 68) = 0x14; *((_BYTE *)this + 69) = 0x54; *((_BYTE *)this + 70) = 0x7F; *((_BYTE *)this + 71) = 0xCF; qmemcpy(this + 18, \u0026#34; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#34;, 20);   sub_4026E0 来到关键的处理函数：\n1 2 3 4 5 6 7 8  int __thiscall sub_4026E0(void *this) { int i; // [esp+4h] [ebp-4h]  for ( i = 0; i \u0026lt; 5; ++i ) (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 0x1C))(this, i); //  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 0x24))(this); // }   同样查表：\n1 2  this+0x1c -\u0026gt; sub_402730 this+0x24 -\u0026gt; sub_4028A0   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  int __thiscall sub_402730(_DWORD *this, int a2) { int v2; // esi  int v3; // ecx  unsigned __int8 v4; // al  char v6; // cf  char v7; // bl  char v8; // t2  int v10; // [esp+Ch] [ebp-30h]  int i; // [esp+14h] [ebp-28h]  int j; // [esp+1Ch] [ebp-20h]  int v13; // [esp+20h] [ebp-1Ch] BYREF  int v14; // [esp+24h] [ebp-18h]  int v15; // [esp+28h] [ebp-14h]  int v16; // [esp+2Ch] [ebp-10h]  int v17; // [esp+30h] [ebp-Ch]  int v18; // [esp+34h] [ebp-8h]  v13 = 0; v14 = 0; v15 = 0; v16 = 0; v17 = 0; v18 = 0; v10 = this[2] + 5 * a2 + 8; // 根据传入的a2取flag的各个部分  for ( i = 0; i \u0026lt; 4; ++i ) *((_BYTE *)\u0026amp;v13 + i) = *(_BYTE *)(i + v10); // 复制内存  v2 = 0; v3 = 4; do { v4 = *((_BYTE *)\u0026amp;v13 + v2); _DL = v4; __asm { rcl dl, 1 } *((_BYTE *)\u0026amp;v15 + v2) = 1; v7 = 0; v6 = 0; do { v8 = v6 \u0026lt;\u0026lt; 7; v6 = v4 \u0026amp; 1; // 影响循环次数  v4 = (v4 \u0026gt;\u0026gt; 1) | v8; ++v7; } while ( v6 ); *((_BYTE *)\u0026amp;v16 + v2++) = v7 - 1; --v3; } while ( v3 ); for ( j = 0; j \u0026lt; 4; ++j ) { *((_BYTE *)\u0026amp;v14 + j) = *((_BYTE *)\u0026amp;v16 + j) + *((_BYTE *)\u0026amp;v15 + j); *((_BYTE *)\u0026amp;v17 + j) = *((char *)\u0026amp;v13 + j) \u0026lt;\u0026lt; *((_BYTE *)\u0026amp;v15 + j); *((_BYTE *)\u0026amp;v18 + j) = (*((char *)\u0026amp;v13 + j) \u0026lt;\u0026lt; (8 - *((_BYTE *)\u0026amp;v16 + j))) | ((unsigned __int8)(*((char *)\u0026amp;v13 + j) \u0026gt;\u0026gt; (8 - *((_BYTE *)\u0026amp;v15 + j))) \u0026lt;\u0026lt; *((_BYTE *)\u0026amp;v15 + j)); } return sub_402F80(\u0026amp;v13); }   v10 = this[2] + 5 * a2 + 8;，a2作为下标，通过-分割开取值，此时外层循环中i为0，所以传入的a2也是0，在x64dbg中存储为ecx，所以此时v10指向的就是flag的第一部分1234：\ndo-while循环中，明显可以看出是针对单字符进行处理的，v2作为索引，每次取一个字符放到v4中，v3作为循环次数，每循环一次减一：\n这里只写了rcl dl,1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  v2 = 0; v3 = 4; do { v4 = *((_BYTE *)\u0026amp;v13 + v2); // 取单个字符  _DL = v4; __asm { rcl dl, 1 } // 循环左移  *((_BYTE *)\u0026amp;v15 + v2) = 1; v7 = 0; v6 = 0; do { v8 = v6 \u0026lt;\u0026lt; 7; v6 = v4 \u0026amp; 1; // 影响循环次数  v4 = (v4 \u0026gt;\u0026gt; 1) | v8; ++v7; } while ( v6 ); *((_BYTE *)\u0026amp;v16 + v2++) = v7 - 1; --v3; } while ( v3 );   x64dbg调试的时候，可以发现rcl下面存在一个jb指令，这个指令受CF位的影响，当CF为1时跳转指令成立，这里跟dl的值有关，当dl产生进位时CF置1，跳转成立，出循环：\n经测试可以发现当0x31左移3次时产生进位，所以此时ebx值为3，那么ebx中记录的就是左移的位数：\n同理，往下对0x31进行右移，当产生进位时CF置1，跳出循环，ebx记录右移次数减一的值：\n这一部分在IDA反编译的不太一样，按照动态调试中体现的汇编更容易理解：\n4次循环之后得到，分别对应0x31 0x32 0x33 0x34，左边的为左移到进位的次数；右边为右移次数减一，这么理解比较奇怪，我觉得可以理解为从右边0的个数：\n如：0x31，二进制为 0011 0001，所以此时右边0的个数为0\n​\t0x32，二进制为 0011 0010，所以此时右边0的个数为1\n​\t0x34，二进制为 0011 0100，所以此时右边0的个数为2\n第二个循环：\n1 2 3 4 5 6  for ( j = 0; j \u0026lt; 4; ++j ) { *((_BYTE *)\u0026amp;v14 + j) = *((_BYTE *)\u0026amp;v16 + j) + *((_BYTE *)\u0026amp;v15 + j); *((_BYTE *)\u0026amp;v17 + j) = *((char *)\u0026amp;v13 + j) \u0026lt;\u0026lt; *((_BYTE *)\u0026amp;v15 + j); *((_BYTE *)\u0026amp;v18 + j) = (*((char *)\u0026amp;v13 + j) \u0026lt;\u0026lt; (8 - *((_BYTE *)\u0026amp;v16 + j))) | ((unsigned __int8)(*((char *)\u0026amp;v13 + j) \u0026gt;\u0026gt; (8 - *((_BYTE *)\u0026amp;v15 + j))) \u0026lt;\u0026lt; *((_BYTE *)\u0026amp;v15 + j)); }   根据第一个循环简化，最终生成三个值，处理每个字符的结果是独立进行计算的，跟位置和前后字符无关，互不影响：\n1 2 3 4 5 6  for ( j = 0; j \u0026lt; 4; ++j ) { res1 = 右边0的个数 + 左移进位次数;\tres2 = flag \u0026lt;\u0026lt; 左移进位次数; res3 = (flag \u0026lt;\u0026lt; (8 - 0的个数)) | ((flag \u0026gt;\u0026gt; (8 - 左移次数)) \u0026lt;\u0026lt; 左移次数); }   这里IDA反编译的res2应该是少了一个移位运算，第一步\n运行之后得到:\n往下走到最后一个处理的函数sub_4028A0，存在while循环，这里while循环的条件为sub_402E00传入v2之后的结果，大致理解为flag的结束，说明while循环针对flag进行遍历的，每个while循环对单个字符进行处理，跟之前的处理一样，不受位置和前后字符值的影响：\n1 2 3  result = sub_402E00(v2); if ( !(_BYTE)result ) break;   在while中存在一个for循环，该循环分为上下两部分，前四次循环会对v15和v15+i+20进行运算处理，后四次循环只对v15进行处理,这里sub_402DC0指向处理后的字符以及sub_402730处理后的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  for ( i = 0; i \u0026lt; 8; ++i ) { if ( i \u0026gt;= 4 ) { v9 = sub_402DC0(v17 + 26); v14 -= *(unsigned __int8 *)(v9 + i); v10 = sub_402DC0(v17 + 26); *v15 |= *(unsigned __int8 *)(v10 + i + 16) \u0026lt;\u0026lt; v14; } else { v4 = sub_402DC0(v17 + 26); v13 = 8 - *(unsigned __int8 *)(v4 + i + 4); v14 -= v13; v5 = sub_402DC0(v17 + 26); *v15 |= *(unsigned __int8 *)(v5 + i + 16) \u0026lt;\u0026lt; v14; v6 = sub_402DC0(v17 + 26); v7 = 16 * *(_BYTE *)(v6 + i + 8); v8 = sub_402DC0(v17 + 26); *((_BYTE *)v15 + i + 20) = *(_BYTE *)(v8 + i + 12) | v7; } }   执行sub_402DC0后返回0xDC41D8:\n根据0xDC41D8指向的内存，可以简化该循环：\n1 2 3 4 5 6 7 8 9 10  if { v9 = sub_402DC0(v17 + 26); v14 -= *(unsigned __int8 *)(v9 + i); // v14的初始值为0x20 \t*v15 |= res3 \u0026lt;\u0026lt; v14; } else { v14 -= 8 - res1; *v15 |= res2 \u0026lt;\u0026lt; v14; *((_BYTE *)v15 + i + 20) = 0的个数 | (16 * 左移进位位数); }   可以发现v15 + i + 20是直接赋值，而这里i注意是跟循环有关，那么每个for循环会生成4个值，而v15注意到DWORD指针，每个for循环也是生成一个DWORD类型的数据，可以判断出while循环应该是进行5次，每次对一部分flag进行处理，最终会得到一个长度为40的结果，调用sub_402A00进行比较\n第一个循环解决之后得到两个值，顺带发现了最终对比的数据就是前面初始化值的数据\n第一个循环：\n1 2  0x11 \u0026lt;\u0026lt; (0x20 - (8 - res1)) = 0x88000000 // 小端存储 0 | (16 * 0x03) = 0x30   第二次循环结束，发现第一部分是会受其他循环影响的，而第二部分是不受其他循环影响的：\n当i\u0026gt;=4时，是直接取res1：\n和res2进行运算：\n1  *v15 |= res2 \u0026lt;\u0026lt; (v14 - res1)   最终的比较：\n分析到这里，整个程序流程基本上就都了解了：\n 校验flag格式 通过-分割flag成5部分，对flag进行位移运算，对flag的每个字符都得到5个结果，将其存储到内存中 进行5次循环，每次循环处理4个字符，利用每个字符得到的5个结果继续进行移位和或运算，最终会生成两个结果，一个结果受字符影响，而另外一个结果是每个字符独立存在，不受其他字符的影响 将得到的结果与初始化中的两个字符串进行对比  exp 第一部分check_1左移进位位数，check_0计算右边0的个数，然后generate计算sub_402730后面的结果，并将三个结果作为list返回：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  def check_1(c): num = 0 while True: c = c \u0026lt;\u0026lt; 1 num += 1 if c \u0026amp; 0x100: return num def check_0(c): # 右边0的个数 num = 0 while True: if c \u0026amp; 1: return num num += 1 c = c \u0026gt;\u0026gt; 1 def generate_0(c): res1 = check_0(c) + check_1(c) res2 = ((c \u0026lt;\u0026lt; check_1(c)) \u0026amp; 0xff) \u0026gt;\u0026gt; res1 res3 = ((c \u0026gt;\u0026gt; (8 - check_1(c))) \u0026lt;\u0026lt; check_1(c)) | ((c \u0026lt;\u0026lt; (8 - check_0(c)) \u0026amp; 0xff) \u0026gt;\u0026gt; res1) return [res1, res2, res3]   第二部分就是通过 03\\\u0026quot;3 0 203\\\u0026quot; $进行字符串排除，这里可以判断flag的范围应该是A-Za-z0-9，通过前面的分析知道每个字符运算的结果互相独立，但是这里可能存在重复的情况，所以先用set去重，然后对set中每个元素作为key，创建一个字典，如果check的结果为key则加入该key的value中，最后返回结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def check_part(c): tmp = list(set(\u0026#39; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#39;)) tmp2 = check_0(c) | (16 * check_1(c)) for i in tmp: if tmp2 == ord(i): return i return \u0026#39;\u0026#39; def classify(): for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits second_part_res = \u0026#39; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#39; res = {} d = dict.fromkeys(list(set(second_part_res))) # print(d) for i in list(set(second_part_res)): d[i] = [] for i in for_each: tmp = check_part(ord(i)) if tmp: d[tmp].append(i) return d   第三部分，test_1作为for循环中前四部分的计算，这里需要注意v14要代入并返回，经过8次运算后，将结果或成一个DWORD值，与first_part对应的DWORD进行对比，如果相等则返回此时循环的4个字符，这里是可以得到唯一值的，最终拼接得到flag：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  def test_1(c, v14): exam = {c: generate_0(ord(c))} v14 = v14 - (8 - exam[c][0]) tmp = exam[c][1] \u0026lt;\u0026lt; v14 return tmp, v14 def test_2(c, v14): exam = {c: generate_0(ord(c))} v14 = v14 - exam[c][0] tmp = exam[c][2] \u0026lt;\u0026lt; v14 return tmp, v14 def check_first_part(second_part, first_part): for i in d[second_part[0]]: for j in d[second_part[1]]: for k in d[second_part[2]]: for m in d[second_part[3]]: v14 = 0x20 tmp, v14 = test_1(i, v14) tmp2, v14 = test_1(j, v14) tmp3, v14 = test_1(k, v14) tmp4, v14 = test_1(m, v14) tmp5, v14 = test_2(i, v14) tmp6, v14 = test_2(j, v14) tmp7, v14 = test_2(k, v14) tmp8, v14 = test_2(m, v14) tmp = tmp | tmp2 | tmp3 | tmp4 | tmp5 | tmp6 | tmp7 | tmp8 if tmp == first_part: return i + j + k + m d = classify() s2 = \u0026#39; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#39; s = [\u0026#39;08\u0026#39;, \u0026#39;EA\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;DE\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;D0\u0026#39;, \u0026#39;3B\u0026#39;, \u0026#39;BE\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;D4\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;B6\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;B7\u0026#39;, \u0026#39;AF\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;54\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;CF\u0026#39;] flag = \u0026#39;swpuctf{\u0026#39; for i in range(0, 5): first_part = int(s[3 + 4 * i]+s[2 + 4 * i]+s[1 + 4 * i]+s[4 * i], 16) second_part = s2[i*4:i*4+4] res = check_first_part(second_part, first_part) if i == 4: flag += res break flag += res + \u0026#39;-\u0026#39; flag += \u0026#39;}\u0026#39;   flag：\n1  swpuctf{we18-l8co-m1e4-58to-swpu}   提交BUUCTF：\n完整exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  import string def check_1(c): # 左移进位位数 num = 0 while True: c = c \u0026lt;\u0026lt; 1 num += 1 if c \u0026amp; 0x100: return num def check_0(c): # 右边0的个数 num = 0 while True: if c \u0026amp; 1: return num num += 1 c = c \u0026gt;\u0026gt; 1 def generate_0(c): res1 = check_0(c) + check_1(c) res2 = ((c \u0026lt;\u0026lt; check_1(c)) \u0026amp; 0xff) \u0026gt;\u0026gt; res1 res3 = ((c \u0026gt;\u0026gt; (8 - check_1(c))) \u0026lt;\u0026lt; check_1(c)) | ((c \u0026lt;\u0026lt; (8 - check_0(c)) \u0026amp; 0xff) \u0026gt;\u0026gt; res1) return [res1, res2, res3] def check_part(c): tmp = list(set(\u0026#39; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#39;)) tmp2 = check_0(c) | (16 * check_1(c)) for i in tmp: if tmp2 == ord(i): return i return \u0026#39;\u0026#39; def classify(): for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits second_part_res = \u0026#39; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#39; d = dict.fromkeys(list(set(second_part_res))) for i in list(set(second_part_res)): d[i] = [] for i in for_each: tmp = check_part(ord(i)) if tmp: d[tmp].append(i) return d def test_1(c, v14): exam = {c: generate_0(ord(c))} v14 = v14 - (8 - exam[c][0]) tmp = exam[c][1] \u0026lt;\u0026lt; v14 return tmp, v14 def test_2(c, v14): exam = {c: generate_0(ord(c))} v14 = v14 - exam[c][0] tmp = exam[c][2] \u0026lt;\u0026lt; v14 return tmp, v14 def calc_first_part(s): v14 = 0x20 tmp, v14 = test_1(s[0], v14) tmp2, v14 = test_1(s[1], v14) tmp3, v14 = test_1(s[2], v14) tmp4, v14 = test_1(s[3], v14) tmp5, v14 = test_2(s[0], v14) tmp6, v14 = test_2(s[1], v14) tmp7, v14 = test_2(s[2], v14) tmp8, v14 = test_2(s[3], v14) return tmp | tmp2 | tmp3 | tmp4 | tmp5 | tmp6 | tmp7 | tmp8 def check_first_part(second_part, first_part): for i in d[second_part[0]]: for j in d[second_part[1]]: for k in d[second_part[2]]: for m in d[second_part[3]]: tmp = i + j + k + m if calc_first_part(tmp) == first_part: return tmp d = classify() s2 = \u0026#39; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#39; s = [\u0026#39;08\u0026#39;, \u0026#39;EA\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;DE\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;D0\u0026#39;, \u0026#39;3B\u0026#39;, \u0026#39;BE\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;D4\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;B6\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;B7\u0026#39;, \u0026#39;AF\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;54\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;CF\u0026#39;] flag = \u0026#39;swpuctf{\u0026#39; for i in range(0, 5): first_part = int(s[3 + 4 * i]+s[2 + 4 * i]+s[1 + 4 * i]+s[4 * i], 16) second_part = s2[i*4:i*4+4] res = check_first_part(second_part, first_part) if i == 4: flag += res break flag += res + \u0026#39;-\u0026#39; flag += \u0026#39;}\u0026#39; print(flag)   优化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  import string class SwpuctfBabyre(): def __init__(self): self.s2 = \u0026#39; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#39; self.s = [\u0026#39;08\u0026#39;, \u0026#39;EA\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;DE\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;D0\u0026#39;, \u0026#39;3B\u0026#39;, \u0026#39;BE\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;D4\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;B6\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;B7\u0026#39;, \u0026#39;AF\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;54\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;CF\u0026#39;] self.flag = \u0026#39;swpuctf{\u0026#39; self.d = dict.fromkeys(list(set(self.s2))) self.v14 = 0x20 for i in list(set(self.s2)): self.d[i] = [] def check_1(self, c): # 左移进位位数 num = 0 while True: c = c \u0026lt;\u0026lt; 1 num += 1 if c \u0026amp; 0x100: return num def check_0(self, c): # 右边0的个数 num = 0 while True: if c \u0026amp; 1: return num num += 1 c = c \u0026gt;\u0026gt; 1 def generate_0(self, c): res1 = self.check_0(c) + self.check_1(c) res2 = ((c \u0026lt;\u0026lt; self.check_1(c)) \u0026amp; 0xff) \u0026gt;\u0026gt; res1 res3 = ((c \u0026gt;\u0026gt; (8 - self.check_1(c))) \u0026lt;\u0026lt; self.check_1(c)) | ((c \u0026lt;\u0026lt; (8 - self.check_0(c)) \u0026amp; 0xff) \u0026gt;\u0026gt; res1) return [res1, res2, res3] def check_part(self, c): tmp = list(set(self.s2)) tmp2 = self.check_0(c) | (16 * self.check_1(c)) for i in tmp: if tmp2 == ord(i): return i return \u0026#39;\u0026#39; def classify(self): for_each = string.ascii_lowercase + string.ascii_uppercase + string.digits for i in for_each: tmp = self.check_part(ord(i)) if tmp: self.d[tmp].append(i) def test_1(self, c): exam = {c: self.generate_0(ord(c))} self.v14 = self.v14 - (8 - exam[c][0]) tmp = exam[c][1] \u0026lt;\u0026lt; self.v14 return tmp def test_2(self, c): exam = {c: self.generate_0(ord(c))} self.v14 = self.v14 - exam[c][0] tmp = exam[c][2] \u0026lt;\u0026lt; self.v14 return tmp def calc_first_part(self, s): self.v14 = 0x20 tmp = 0 for i in s: tmp |= self.test_1(i) for i in s: tmp |= self.test_2(i) return tmp def check_first_part(self, second_part, first_part): for i in self.d[second_part[0]]: for j in self.d[second_part[1]]: for k in self.d[second_part[2]]: for m in self.d[second_part[3]]: tmp = i + j + k + m if self.calc_first_part(tmp) == first_part: return tmp def run(self): self.classify() for i in range(0, 5): first_part = int(self.s[3 + 4 * i]+self.s[2 + 4 * i]+self.s[1 + 4 * i]+self.s[4 * i], 16) second_part = self.s2[i*4:i*4+4] res = self.check_first_part(second_part, first_part) if i == 4: self.flag += res break self.flag += res + \u0026#39;-\u0026#39; self.flag += \u0026#39;}\u0026#39; print(self.flag) if __name__ == \u0026#39;__main__\u0026#39;: swpuctf = SwpuctfBabyre() swpuctf.run()   ","date":"2022-03-01T00:00:00Z","permalink":"https://YuSec2021.github.io/p/ctf/swpuctf2019_easyre/","title":"easyRE 解题脚本及详细分析过程"},{"content":"解题 ELF64程序，无壳，IDA反编译main函数，这里我稍微做了重命名，看起来比较清楚：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  __int64 __fastcall main(int a1, char **a2, char **a3) { __int64 result; // rax  char suf_flag[33]; // [rsp+0h] [rbp-250h] BYREF  char pre_flag[15]; // [rsp+21h] [rbp-22Fh] BYREF  char v6[256]; // [rsp+30h] [rbp-220h] BYREF  char encode_flag[256]; // [rsp+130h] [rbp-120h] BYREF  void *src; // [rsp+230h] [rbp-20h]  void *dest; // [rsp+238h] [rbp-18h]  int v10; // [rsp+244h] [rbp-Ch]  int j; // [rsp+248h] [rbp-8h]  int i; // [rsp+24Ch] [rbp-4h]  printf(\u0026#34;your flag:\u0026#34;); __isoc99_scanf(\u0026#34;%s\u0026#34;, v6); putchar(10); if ( v6[15] == \u0026#39;-\u0026#39; ) { for ( i = 0; i \u0026lt;= 14; ++i ) pre_flag[i] = v6[i]; for ( j = 0; j \u0026lt;= 17; ++j ) suf_flag[j] = v6[j + 16]; v10 = decode_puzzle((__int64)pre_flag); if ( v10 == 1 ) { dest = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL); src = (void *)generate_machine_code(); memcpy(dest, src, 0x28CuLL); ((void (__fastcall *)(char *, char *, void *))dest)(encode_flag, suf_flag, \u0026amp;unk_404320); v10 = check_encode(encode_flag); if ( v10 ) puts(\u0026#34;congratulations!\u0026#34;); else printf(\u0026#34;nonono\u0026#34;); result = 0LL; } else { printf(\u0026#34;nonono\u0026#34;); result = 0LL; } } else { printf(\u0026#34;nonono\u0026#34;); result = 0LL; } return result; }   可以看到flag是通过-分成两部分进行校验：\n第一部分是通过一个迷宫puzzle，其走法即为上半部分flag，这里只能走.，终点为B:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  __int64 __fastcall sub_401192(__int64 a1) { int v1; // eax  int i; // [rsp+Ch] [rbp-Ch]  int line; // [rsp+10h] [rbp-8h]  int row; // [rsp+14h] [rbp-4h]  row = 1; line = 0; for ( i = 0; i \u0026lt;= 14; ++i ) { v1 = *(unsigned __int8 *)(i + a1); if ( v1 == \u0026#39;w\u0026#39; ) { --line; } else if ( *(unsigned __int8 *)(i + a1) \u0026lt;= 0x77u ) { if ( v1 == \u0026#39;s\u0026#39; ) { ++line; } else if ( *(unsigned __int8 *)(i + a1) \u0026lt;= 0x73u ) { if ( v1 == \u0026#39;a\u0026#39; ) { --row; } else if ( v1 == \u0026#39;d\u0026#39; ) { ++row; } } } if ( aAB[11 * line + row] == \u0026#39;B\u0026#39; ) return 1LL; if ( aAB[11 * line + row] != \u0026#39;.\u0026#39; ) return 0LL; } return 0LL; }   根据下标的获取，很容易知道这是一个11列的矩阵，根据这个就可以划出迷宫了：\n1 2 3 4 5  *A********* *.***.....* *.....***.* ********..* ********B**   得到上半部分的flag：ssddddwddddssas\n下半部分的关键在这五行代码：\n1 2 3 4 5  dest = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL); src = (void *)generate_machine_code(); memcpy(dest, src, 0x28CuLL); ((void (__fastcall *)(char *, char *, void *))dest)(encode_flag, suf_flag, \u0026amp;unk_404320); v10 = check_encode(encode_flag);   IDA反编译中调用mmap进行地址映射，然后调用generate_machine_code()来生成机器码，将这里的数据赋值到mmap映射的地址中，然后传入三个参数，将suf_flag作为text，unk_404320作为key进行加密，得到的结果存入encode_flag中，最后与r60ihyZ/m4lseHt+m4t+mIkc进行比较 所以这里关键就在机器码生成和key的处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  _BYTE *generate_machine_code() { _BYTE *v1; // [rsp+8h] [rbp-18h]  int j; // [rsp+14h] [rbp-Ch]  int i; // [rsp+18h] [rbp-8h]  int v4; // [rsp+1Ch] [rbp-4h]  v1 = malloc(0x200uLL); v4 = 0; for ( i = 0; i \u0026lt; 652; ++i ) { if ( v4 == 64 ) v4 = 0; v1[i] = byte_404080[i] ^ byte_404360[v4++]; } for ( j = 0; j \u0026lt;= 63; ++j ) byte_404320[j] ^= byte_404360[j]; return v1; }   python脚本生成一下数据，生成机器码和加密用的key：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  byte_404360 = [\u0026#39;3E\u0026#39;, \u0026#39;7A\u0026#39;, \u0026#39;40\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;27\u0026#39;, \u0026#39;25\u0026#39;, \u0026#39;48\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;4F\u0026#39;, \u0026#39;63\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;60\u0026#39;, \u0026#39;0B\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;75\u0026#39;, \u0026#39;5D\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;30\u0026#39;, \u0026#39;4C\u0026#39;, \u0026#39;4B\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;5F\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;1A\u0026#39;, \u0026#39;38\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;34\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;45\u0026#39;, \u0026#39;47\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;3B\u0026#39;, \u0026#39;74\u0026#39;, \u0026#39;7D\u0026#39;, \u0026#39;2C\u0026#39;, \u0026#39;2B\u0026#39;, \u0026#39;4A\u0026#39;, \u0026#39;3C\u0026#39;, \u0026#39;29\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;70\u0026#39;, \u0026#39;52\u0026#39;, \u0026#39;65\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;59\u0026#39;, \u0026#39;6C\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;72\u0026#39;, \u0026#39;3D\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;55\u0026#39;, \u0026#39;41\u0026#39;, \u0026#39;49\u0026#39;] byte_404320 = [\u0026#39;4D\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;43\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;7A\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;39\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;53\u0026#39;, \u0026#39;66\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;60\u0026#39;, \u0026#39;76\u0026#39;, \u0026#39;75\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;68\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;7B\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;49\u0026#39;, \u0026#39;0F\u0026#39;, \u0026#39;2E\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;66\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;53\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;34\u0026#39;, \u0026#39;6E\u0026#39;, \u0026#39;69\u0026#39;, \u0026#39;2F\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;6A\u0026#39;, \u0026#39;49\u0026#39;, \u0026#39;55\u0026#39;, \u0026#39;36\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;2A\u0026#39;, \u0026#39;6B\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;0B\u0026#39;] byte_404380 = [\u0026#39;6B\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;C9\u0026#39;, \u0026#39;81\u0026#39;, \u0026#39;6F\u0026#39;, \u0026#39;AC\u0026#39;, \u0026#39;35\u0026#39;, \u0026#39;DC\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;EA\u0026#39;, \u0026#39;6C\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;43\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;95\u0026#39;, \u0026#39;59\u0026#39;, \u0026#39;C5\u0026#39;, \u0026#39;52\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;C7\u0026#39;, \u0026#39;0E\u0026#39;, \u0026#39;D6\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;72\u0026#39;, \u0026#39;DD\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;8E\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B8\u0026#39;, \u0026#39;31\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;B8\u0026#39;, \u0026#39;31\u0026#39;, \u0026#39;8D\u0026#39;, \u0026#39;2D\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;AD\u0026#39;, \u0026#39;AC\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;D4\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;C7\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;52\u0026#39;, \u0026#39;2D\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;6F\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;E3\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;27\u0026#39;, \u0026#39;68\u0026#39;, \u0026#39;67\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;1C\u0026#39;, \u0026#39;76\u0026#39;, \u0026#39;F3\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;2C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;CF\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;8D\u0026#39;, \u0026#39;81\u0026#39;, \u0026#39;2B\u0026#39;, \u0026#39;D8\u0026#39;, \u0026#39;9E\u0026#39;, \u0026#39;34\u0026#39;, \u0026#39;72\u0026#39;, \u0026#39;FC\u0026#39;, \u0026#39;8D\u0026#39;, \u0026#39;59\u0026#39;, \u0026#39;67\u0026#39;, \u0026#39;F7\u0026#39;, \u0026#39;0C\u0026#39;, \u0026#39;B9\u0026#39;, \u0026#39;8E\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8D\u0026#39;, \u0026#39;3B\u0026#39;, \u0026#39;0C\u0026#39;, \u0026#39;D8\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;81\u0026#39;, \u0026#39;FC\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;6C\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;BE\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;63\u0026#39;, \u0026#39;C1\u0026#39;, \u0026#39;71\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;5B\u0026#39;, \u0026#39;BB\u0026#39;, \u0026#39;69\u0026#39;, \u0026#39;56\u0026#39;, \u0026#39;34\u0026#39;, \u0026#39;25\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;5C\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;48\u0026#39;, \u0026#39;F6\u0026#39;, \u0026#39;91\u0026#39;, \u0026#39;24\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;98\u0026#39;, \u0026#39;75\u0026#39;, \u0026#39;F3\u0026#39;, \u0026#39;AC\u0026#39;, \u0026#39;7E\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;B7\u0026#39;, \u0026#39;AA\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;4D\u0026#39;, \u0026#39;EF\u0026#39;, \u0026#39;6D\u0026#39;, \u0026#39;89\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;4D\u0026#39;, \u0026#39;2B\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;25\u0026#39;, \u0026#39;F3\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;5F\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;9A\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;F7\u0026#39;, \u0026#39;0C\u0026#39;, \u0026#39;8A\u0026#39;, \u0026#39;1A\u0026#39;, \u0026#39;1E\u0026#39;, \u0026#39;53\u0026#39;, \u0026#39;0A\u0026#39;, \u0026#39;26\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;4F\u0026#39;, \u0026#39;6D\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;BD\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B2\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;B5\u0026#39;, \u0026#39;84\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;63\u0026#39;, \u0026#39;C3\u0026#39;, \u0026#39;EC\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;C9\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;A1\u0026#39;, \u0026#39;71\u0026#39;, \u0026#39;1A\u0026#39;, \u0026#39;A4\u0026#39;, \u0026#39;E9\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;48\u0026#39;, \u0026#39;F6\u0026#39;, \u0026#39;1C\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;F9\u0026#39;, \u0026#39;68\u0026#39;, \u0026#39;CA\u0026#39;, \u0026#39;1D\u0026#39;, \u0026#39;CA\u0026#39;, \u0026#39;0C\u0026#39;, \u0026#39;E6\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;41\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;E1\u0026#39;, \u0026#39;25\u0026#39;, \u0026#39;48\u0026#39;, \u0026#39;C3\u0026#39;, \u0026#39;0A\u0026#39;, \u0026#39;8F\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;0B\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;B2\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;F9\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;A5\u0026#39;, \u0026#39;54\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;5F\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;86\u0026#39;, \u0026#39;5F\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;57\u0026#39;, \u0026#39;A8\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;CC\u0026#39;, \u0026#39;1D\u0026#39;, \u0026#39;EB\u0026#39;, \u0026#39;3C\u0026#39;, \u0026#39;7C\u0026#39;, \u0026#39;FC\u0026#39;, \u0026#39;24\u0026#39;, \u0026#39;FC\u0026#39;, \u0026#39;3C\u0026#39;, \u0026#39;E9\u0026#39;, \u0026#39;FB\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;B5\u0026#39;, \u0026#39;B1\u0026#39;, \u0026#39;38\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;C1\u0026#39;, \u0026#39;6A\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;AF\u0026#39;, \u0026#39;D2\u0026#39;, \u0026#39;39\u0026#39;, \u0026#39;9B\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;5E\u0026#39;, \u0026#39;F8\u0026#39;, \u0026#39;1D\u0026#39;, \u0026#39;CA\u0026#39;, \u0026#39;1C\u0026#39;, \u0026#39;E6\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;41\u0026#39;, \u0026#39;AE\u0026#39;, \u0026#39;28\u0026#39;, \u0026#39;93\u0026#39;, \u0026#39;48\u0026#39;, \u0026#39;8C\u0026#39;, \u0026#39;4D\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;5C\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;43\u0026#39;, \u0026#39;59\u0026#39;, \u0026#39;A5\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;9A\u0026#39;, \u0026#39;0B\u0026#39;, \u0026#39;D7\u0026#39;, \u0026#39;0C\u0026#39;, \u0026#39;31\u0026#39;, \u0026#39;9C\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;5F\u0026#39;, \u0026#39;7C\u0026#39;, \u0026#39;BB\u0026#39;,\u0026#39;DA\u0026#39;, \u0026#39;F9\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;FB\u0026#39;, \u0026#39;A5\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;F9\u0026#39;, \u0026#39;FF\u0026#39;, \u0026#39;38\u0026#39;, \u0026#39;C4\u0026#39;, \u0026#39;63\u0026#39;, \u0026#39;D2\u0026#39;, \u0026#39;74\u0026#39;, \u0026#39;A4\u0026#39;, \u0026#39;5B\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;24\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;1A\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;C1\u0026#39;, \u0026#39;2D\u0026#39;,\u0026#39;B6\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;99\u0026#39;, \u0026#39;84\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;7D\u0026#39;, \u0026#39;8B\u0026#39;, \u0026#39;F2\u0026#39;, \u0026#39;5C\u0026#39;, \u0026#39;91\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;5D\u0026#39;, \u0026#39;AA\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;EF\u0026#39;, \u0026#39;62\u0026#39;, \u0026#39;ED\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;9F\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;4C\u0026#39;, \u0026#39;8C\u0026#39;, \u0026#39;43\u0026#39;, \u0026#39;59\u0026#39;, \u0026#39;A7\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;9C\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;0C\u0026#39;, \u0026#39;BB\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;93\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;5E\u0026#39;, \u0026#39;B9\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;AC\u0026#39;, \u0026#39;38\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;36\u0026#39;, \u0026#39;F3\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;AF\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;A3\u0026#39;, \u0026#39;3C\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;7C\u0026#39;, \u0026#39;2A\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;B7\u0026#39;, \u0026#39;6C\u0026#39;, \u0026#39;C3\u0026#39;, \u0026#39;49\u0026#39;, \u0026#39;3E\u0026#39;, \u0026#39;D3\u0026#39;, \u0026#39;6E\u0026#39;, \u0026#39;C6\u0026#39;, \u0026#39;52\u0026#39;, \u0026#39;6A\u0026#39;, \u0026#39;BF\u0026#39;, \u0026#39;E2\u0026#39;, \u0026#39;C1\u0026#39;, \u0026#39;9F\u0026#39;, \u0026#39;5B\u0026#39;, \u0026#39;EF\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;DE\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;A1\u0026#39;, \u0026#39;76\u0026#39;, \u0026#39;E2\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;E9\u0026#39;, \u0026#39;6F\u0026#39;,\u0026#39;27\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;8F\u0026#39;, \u0026#39;0A\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;51\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;C3\u0026#39;, \u0026#39;35\u0026#39;, \u0026#39;C3\u0026#39;, \u0026#39;5D\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;A6\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;4B\u0026#39;, \u0026#39;86\u0026#39;, \u0026#39;8C\u0026#39;, \u0026#39;42\u0026#39;, \u0026#39;D6\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;DD\u0026#39;, \u0026#39;52\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;4D\u0026#39;, \u0026#39;FC\u0026#39;, \u0026#39;3\u0026#39;,\u0026#39;44\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;D3\u0026#39;, \u0026#39;6E\u0026#39;, \u0026#39;98\u0026#39;, \u0026#39;35\u0026#39;, \u0026#39;4F\u0026#39;, \u0026#39;F9\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;B1\u0026#39;, \u0026#39;63\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;49\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;56\u0026#39;, \u0026#39;B9\u0026#39;, \u0026#39;38\u0026#39;, \u0026#39;53\u0026#39;, \u0026#39;AF\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;F7\u0026#39;, \u0026#39;5B\u0026#39;, \u0026#39;E7\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;9A\u0026#39;,\u0026#39;75\u0026#39;, \u0026#39;AA\u0026#39;, \u0026#39;1D\u0026#39;, \u0026#39;CC\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;3C\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;CB\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;F7\u0026#39;, \u0026#39;6D\u0026#39;, \u0026#39;49\u0026#39;, \u0026#39;D4\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;6F\u0026#39;, \u0026#39;BD\u0026#39;, \u0026#39;FA\u0026#39;, \u0026#39;F6\u0026#39;, \u0026#39;BD\u0026#39;, \u0026#39;2E\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;8E\u0026#39;, \u0026#39;86\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;C7\u0026#39;, \u0026#39;0E\u0026#39;, \u0026#39;CE\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;72\u0026#39;, \u0026#39;DD\u0026#39;, \u0026#39;91\u0026#39;, \u0026#39;6D\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;7C\u0026#39;, \u0026#39;1B\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;0F\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;71\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;35\u0026#39;, \u0026#39;A7\u0026#39;, \u0026#39;7E\u0026#39;, \u0026#39;92\u0026#39;, \u0026#39;74\u0026#39;, \u0026#39;28\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;0E\u0026#39;, \u0026#39;89\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;E9\u0026#39;, \u0026#39;72\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;E1\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;83\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;B5\u0026#39;, \u0026#39;68\u0026#39;, \u0026#39;FC\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;7A\u0026#39;, \u0026#39;CD\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;C2\u0026#39;, \u0026#39;6B\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;E7\u0026#39;, \u0026#39;CD\u0026#39;, \u0026#39;27\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;3D\u0026#39;, \u0026#39;9F\u0026#39;, \u0026#39;6C\u0026#39;, \u0026#39;95\u0026#39;, \u0026#39;AB\u0026#39;, \u0026#39;F5\u0026#39;, \u0026#39;C5\u0026#39;, \u0026#39;8A\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;9A\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;F7\u0026#39;, \u0026#39;0C\u0026#39;, \u0026#39;8A\u0026#39;, \u0026#39;1A\u0026#39;, \u0026#39;1E\u0026#39;, \u0026#39;53\u0026#39;, \u0026#39;0A\u0026#39;, \u0026#39;26\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;4F\u0026#39;, \u0026#39;6D\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;BD\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B2\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;FD\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;EA\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;9A\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;2A\u0026#39;, \u0026#39;91\u0026#39;, \u0026#39;38\u0026#39;, \u0026#39;DB\u0026#39;, \u0026#39;A7\u0026#39;, \u0026#39;41\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;D2\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;AE\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;FB\u0026#39;, \u0026#39;F5\u0026#39;, \u0026#39;7A\u0026#39;, \u0026#39;7C\u0026#39;, \u0026#39;91\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;BD\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;41\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2F\u0026#39;, \u0026#39;6D\u0026#39;, \u0026#39;CB\u0026#39;, \u0026#39;FC\u0026#39;, \u0026#39;4D\u0026#39;, \u0026#39;17\u0026#39;, \u0026#39;33\u0026#39;, \u0026#39;8B\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;B1\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;B1\u0026#39;, \u0026#39;59\u0026#39;, \u0026#39;D6\u0026#39;, \u0026#39;4F\u0026#39;, \u0026#39;C9\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;B2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;8D\u0026#39;, \u0026#39;1A\u0026#39;, \u0026#39;AB\u0026#39;, \u0026#39;45\u0026#39;, \u0026#39;1B\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;CE\u0026#39;, \u0026#39;34\u0026#39;, \u0026#39;45\u0026#39;, \u0026#39;CE\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;EC\u0026#39;, \u0026#39;35\u0026#39;, \u0026#39;A1\u0026#39;, \u0026#39;7B\u0026#39;, \u0026#39;B5\u0026#39;, \u0026#39;74\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;56\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;B1\u0026#39;, \u0026#39;B6\u0026#39;, \u0026#39;52\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;E2\u0026#39;, \u0026#39;36\u0026#39;, \u0026#39;8B\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;B5\u0026#39;, \u0026#39;24\u0026#39;, \u0026#39;EF\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;62\u0026#39;, \u0026#39;AA\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;C2\u0026#39;, \u0026#39;7B\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;65\u0026#39;, \u0026#39;F7\u0026#39;, \u0026#39;E3\u0026#39;, \u0026#39;48\u0026#39;, \u0026#39;39\u0026#39;, \u0026#39;DF\u0026#39;, \u0026#39;F3\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;A3\u0026#39;] tmp_404360 = [] tmp_404320 = [] tmp_404380 = [] # 将16进制全部转成10进制 for i in byte_404360: tmp_404360.append(int(i, 16)) byte_404360 = tmp_404360 print(byte_404360) for i in byte_404320: tmp_404320.append(int(i, 16)) byte_404320 = tmp_404320 print(byte_404320) for i in byte_404380: tmp_404380.append(int(i, 16)) byte_404380 = tmp_404380 print(byte_404380) # 获取OPCODE opcode = [] for i in range(0, len(byte_404380)): tmp = byte_404380[i] ^ byte_404360[i % 64] src.append(hex(tmp)) print(opcode) # 获取KEY key = [] for i in range(0, len(byte_404320)): key.append(byte_404320[i] ^ byte_404360[i]) print(key)   这里看到加密后的数据，很容易联想到是base64处理后的数据，这里key又是64个字符，所以猜测应该是修改了码表的base64，尝试验证一下，先将异或后的key转成字符：\n1 2 3 4 5  key = [115, 90, 71, 97, 100, 48, 50, 119, 118, 98, 102, 51, 109, 116, 120, 69, 113, 56, 114, 68, 104, 89, 75, 52, 55, 76, 117, 101, 67, 108, 122, 49, 74, 105, 103, 54, 121, 112, 72, 77, 43, 111, 47, 87, 53, 81, 106, 78, 80, 70, 82, 99, 107, 85, 73, 110, 79, 84, 88, 86, 65, 83, 57, 66] base64_xor_table = \u0026#39;\u0026#39; for i in key: base64_xor_table += chr(i)   可以发现该key并未存在字母重复，猜测应该就是base64码表替换：sZGad02wvbf3mtxEq8rDhYK47LueClz1Jig6ypHM+o/W5QjNPFRckUInOTXVAS9B\n1 2 3 4 5 6 7  import base64 encode_flag = \u0026#39;r60ihyZ/m4lseHt+m4t+mIkc\u0026#39; outtab = \u0026#39;sZGad02wvbf3mtxEq8rDhYK47LueClz1Jig6ypHM+o/W5QjNPFRckUInOTXVAS9B\u0026#39; intab = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; suf_flag = base64.b64decode(encode_flag.translate(str.maketrans(outtab, intab)))   得到：J1aR@j1w@nch1sh3m3\n拼接得到最终flag：\nflag{ssddddwddddssas-J1aR@j1w@nch1sh3m3}\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  byte_404360 = [\u0026#39;3E\u0026#39;, \u0026#39;7A\u0026#39;, \u0026#39;40\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;27\u0026#39;, \u0026#39;25\u0026#39;, \u0026#39;48\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;4F\u0026#39;, \u0026#39;63\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;60\u0026#39;, \u0026#39;0B\u0026#39;, \u0026#39;3A\u0026#39;, \u0026#39;75\u0026#39;, \u0026#39;5D\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;30\u0026#39;, \u0026#39;4C\u0026#39;, \u0026#39;4B\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;5F\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;1A\u0026#39;, \u0026#39;38\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;34\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;45\u0026#39;, \u0026#39;47\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;3B\u0026#39;, \u0026#39;74\u0026#39;, \u0026#39;7D\u0026#39;, \u0026#39;2C\u0026#39;, \u0026#39;2B\u0026#39;, \u0026#39;4A\u0026#39;, \u0026#39;3C\u0026#39;, \u0026#39;29\u0026#39;, \u0026#39;13\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;70\u0026#39;, \u0026#39;52\u0026#39;, \u0026#39;65\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;59\u0026#39;, \u0026#39;6C\u0026#39;, \u0026#39;77\u0026#39;, \u0026#39;72\u0026#39;, \u0026#39;3D\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;55\u0026#39;, \u0026#39;41\u0026#39;, \u0026#39;49\u0026#39;] byte_404320 = [\u0026#39;4D\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;43\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;7A\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;39\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;53\u0026#39;, \u0026#39;66\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;60\u0026#39;, \u0026#39;76\u0026#39;, \u0026#39;75\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;58\u0026#39;, \u0026#39;15\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;32\u0026#39;, \u0026#39;68\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;7F\u0026#39;, \u0026#39;7B\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;4E\u0026#39;, \u0026#39;49\u0026#39;, \u0026#39;0F\u0026#39;, \u0026#39;2E\u0026#39;, \u0026#39;3F\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;0D\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;66\u0026#39;, \u0026#39;61\u0026#39;, \u0026#39;53\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;34\u0026#39;, \u0026#39;6E\u0026#39;, \u0026#39;69\u0026#39;, \u0026#39;2F\u0026#39;, \u0026#39;20\u0026#39;, \u0026#39;14\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;6A\u0026#39;, \u0026#39;49\u0026#39;, \u0026#39;55\u0026#39;, \u0026#39;36\u0026#39;, \u0026#39;37\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;2A\u0026#39;, \u0026#39;6B\u0026#39;, \u0026#39;73\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;78\u0026#39;, \u0026#39;0B\u0026#39;] tmp_404360 = [] tmp_404320 = [] # 将16进制全部转成10进制 for i in byte_404360: tmp_404360.append(int(i, 16)) byte_404360 = tmp_404360 for i in byte_404320: tmp_404320.append(int(i, 16)) byte_404320 = tmp_404320 # 获取KEY key = [] for i in range(0, len(byte_404320)): key.append(byte_404320[i] ^ byte_404360[i]) #print(key) outtab = \u0026#39;\u0026#39; for i in key: outtab += chr(i) #print(outtab) import base64 pre_flag = \u0026#39;ssddddwddddssas\u0026#39; encode_flag = \u0026#39;r60ihyZ/m4lseHt+m4t+mIkc\u0026#39; intab = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; suf_flag = base64.b64decode(encode_flag.translate(str.maketrans(outtab, intab))) flag = \u0026#39;flag{\u0026#39; + pre_flag + \u0026#39;-\u0026#39; + suf_flag.decode() + \u0026#39;}\u0026#39; print(flag)   ","date":"2022-03-01T00:00:00Z","permalink":"https://YuSec2021.github.io/p/ctf/qiangwang_re/","title":"SimpleRE 分析及解题脚本"},{"content":"[ACTF新生赛2020]Splendid_MineCraft 解密字节码 反编译源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // eax  char *v4; // eax  char v6; // [esp+0h] [ebp-68h]  int i; // [esp+14h] [ebp-54h]  char *v8; // [esp+18h] [ebp-50h]  char v9; // [esp+20h] [ebp-48h]  char flag[25]; // [esp+24h] [ebp-44h] BYREF  char v11[25]; // [esp+25h] [ebp-43h] BYREF  char v12; // [esp+3Dh] [ebp-2Bh]  int v13; // [esp+44h] [ebp-24h]  __int16 v14; // [esp+48h] [ebp-20h]  char v15[4]; // [esp+4Ch] [ebp-1Ch]  __int16 v16; // [esp+50h] [ebp-18h]  int v17; // [esp+54h] [ebp-14h] BYREF  __int16 v18; // [esp+58h] [ebp-10h]  int v19; // [esp+5Ch] [ebp-Ch]  __int16 v20; // [esp+60h] [ebp-8h]  sub_401020(\u0026#34;%s\\n\u0026#34;, (char)aWelcomeToActfS); sub_401050(\u0026#34;%s\u0026#34;, (char)flag); if ( \u0026amp;flag[strlen(flag) + 1] - v11 == 26 \u0026amp;\u0026amp; !strncmp(flag, \u0026#34;ACTF{\u0026#34;, 5u) \u0026amp;\u0026amp; v12 == \u0026#39;}\u0026#39; ) { v12 = 0; v3 = strtok(flag, \u0026#34;_\u0026#34;); v17 = *(_DWORD *)(v3 + 5); v18 = *(_WORD *)(v3 + 9); v19 = *(_DWORD *)(v3 + 5); v20 = *(_WORD *)(v3 + 9); v4 = strtok(0, \u0026#34;_\u0026#34;); v13 = *(_DWORD *)v4; v14 = *((_WORD *)v4 + 2); v8 = strtok(0, \u0026#34;_\u0026#34;); *(_DWORD *)v15 = *(_DWORD *)v8; v16 = *((_WORD *)v8 + 2); dword_403354 = (int)\u0026amp;unk_4051D8; if ( ((int (__cdecl *)(int *))unk_4051D8)(\u0026amp;v17) ) { v9 = BYTE2(v19) ^ HIBYTE(v20) ^ v19 ^ HIBYTE(v19) ^ BYTE1(v19) ^ v20; for ( i = 256; i \u0026lt; 496; ++i ) byte_405018[i] ^= v9; __asm { jmp eax } } } sub_401020(\u0026#34;Wrong\\n\u0026#34;, v6); return 0; }   条件判断：\n1  \u0026amp;flag[strlen(flag) + 1] - v11 == 26 \u0026amp;\u0026amp; !strncmp(flag, \u0026#34;ACTF{\u0026#34;, 5u) \u0026amp;\u0026amp; v12 == \u0026#39;}\u0026#39;   第一个判断是输入的flag的最后一个字符的地址-v11的起始地址是否等于26，应该就是需要flag的长度为26：\n1  cyclic 26 -\u0026gt; flag{aaaabaaacaaadaaaeaaa}   后面两个判断就是判断flag的格式为：ACTF{xxxx}\nstrtok，用_将字符串分隔开，v3取的是最左边的一段字符，ACTF{xxxx，注意v17是从第六个字符开始，取4个字符的长度，然后v18是从第10个字符开始，取两个字符，这样其实都可以推断出来整个flag的格式为ACTF{xxxxxx_xxxxxx_xxxxxx}\n1 2 3 4 5 6 7 8 9 10 11  v3 = strtok(flag, \u0026#34;_\u0026#34;); v17 = *(_DWORD *)(v3 + 5); v18 = *(_WORD *)(v3 + 9); v19 = *(_DWORD *)(v3 + 5); v20 = *(_WORD *)(v3 + 9); v4 = strtok(0, \u0026#34;_\u0026#34;); v13 = *(_DWORD *)v4; v14 = *((_WORD *)v4 + 2); v8 = strtok(0, \u0026#34;_\u0026#34;); *(_DWORD *)v15 = *(_DWORD *)v8; v16 = *((_WORD *)v8 + 2);   往下存在一个unk_4051D8：\n发现把unk_4051D8当成函数执行：((int (__cdecl *)(int *))unk_4051D8)(\u0026amp;v17)，说明上面的一大段数据应该是字节码，然后将v17当成参数传入该函数中，重新运行，输入ACTF{aaaaaa_bbbbbb_cccccc}，用x32dbg动态跟：\n第一个循环：\n1 2 3 4  esi = 0xE351DD for edi in range(0, 0x151): tmp = byte ptr [esi + edi + 0x1F] [esi+edi+0x1F] = tmp ^ 0x72   异或结果：\n看到EIP，发现就是通过循环解密出后面需要执行的字节码：\n第一部分解密 解密之后的push ebp才是真正的函数开始，该函数先是往内存写值，一个是3@1b;b，一个是Welcome：\n往下对刚刚写入的字符串的进行循环异或，\n1 2 3 4 5  a = \u0026#39;3@1b;b\u0026#39; b = \u0026#39;elcome\u0026#39; res = \u0026#39;\u0026#39; for i in range(0, len(a)): res += chr(a[i] ^ b[i] + 0x23)   6次循环后得到：yOu0y*\n最后出循环，test eax, eax，说明eax是作为函数执行结果，\n重新运行执行输入：\nACTF{abcdef_hijklm_opqrst}\n处理完第一个strtok之后会得到一个字符串为：abcdefRvabcdef，中间的Rv是固定的\n三次strtok处理完之后会得到这样的结果：\n然后来到字节码部分，注意传进来的字符串为：abcdefRvabcdef\n进来之后先对字节码进行解密，解谜之后从0x9F515C开始才是函数处理的开始，注意传入的参数由EDX指向：\n随后生成3@1b;b和welcome，对这两个值进行异或再加上0x23，然后跟传入的字符串进行对比，不难发现预期值应该是两个相等的，往下走完循环拿完处理后的结果为yOu0y*\n重新运行：\n此时相等了，跳转不实现：\n将edx作为计数器来存储相等的个数，最后对比是否全部相等，将返回值置为1：\n第二部分解密 往下来到第二个部分的验证：\n1 2  res = \u0026#39;yOu0y*\u0026#39; key = res[0] ^ res[1] ^ res[3] ^ res[0] ^ res[5] ^ res[2] =   异或之后的值作为key，然后对：405018开始的值进行异或，跟第一个函数一样，通过这个key对字节码进行解密，然后再执行，这里的内容就是第二部分字符串的验证:\n开局几个循环啥事都没干就是将输入的第二部分字符串进行memcpy，到这个位置才真正对字符串进行处理：\n往下的mov很重要，EAX此时的值为0x705018，也就是该函数的字节码首地址，这里异或的结果作为数组下标，将字节码以byte的形式存储到EBX：\n往下从0x705018+0x166取值与上面通过偏移拿到的值进行比较：\nedi作为计数器，回到异或之前可以看到ecx的值来自于edi：\n得到异或逻辑为：\n1 2 3 4 5  res2 = [0x30,4,4,3,0x30,0x63] flag2 = \u0026#39;xxxxxx\u0026#39; byte_405018 = [...] for i in range(0, len(flag2)): cmp byte_405018[flag2[i] ^ (i+0x83)], ord(str2[i])   exp：\n1 2 3 4 5  res2 = [0x30,4,4,3,0x30,0x63] flag2 = \u0026#39;\u0026#39; byte_405018 = [...] for i in range(0, len(res2)): flag2 += chr((0x83+i)^ byte_405018.index(res2[i]))   byte_405018，用Ghidra的字节复制复制下来：\n1  [ 0xf6, 0xa3, 0x5b, 0x9d, 0xe0, 0x95, 0x98, 0x68, 0x8c, 0x65, 0xbb, 0x76, 0x89, 0xd4, 0x09, 0xfd, 0xf3, 0x5c, 0x3c, 0x4c, 0x36, 0x8e, 0x4d, 0xc4, 0x80, 0x44, 0xd6, 0xa9, 0x01, 0x32, 0x77, 0x29, 0x90, 0xbc, 0xc0, 0xa8, 0xd8, 0xf9, 0xe1, 0x1d, 0xe4, 0x67, 0x7d, 0x2a, 0x2c, 0x59, 0x9e, 0x3d, 0x7a, 0x34, 0x11, 0x43, 0x74, 0xd1, 0x62, 0x60, 0x02, 0x4b, 0xae, 0x99, 0x57, 0xc6, 0x73, 0xb0, 0x33, 0x18, 0x2b, 0xfe, 0xb9, 0x85, 0xb6, 0xd9, 0xde, 0x7b, 0xcf, 0x4f, 0xb3, 0xd5, 0x08, 0x7c, 0x0a, 0x71, 0x12, 0x06, 0x37, 0xff, 0x7f, 0xb7, 0x46, 0x42, 0x25, 0xc9, 0xd0, 0x50, 0x52, 0xce, 0xbd, 0x6c, 0xe5, 0x6f, 0xa5, 0x15, 0xed, 0x64, 0xf0, 0x23, 0x35, 0xe7, 0x0c, 0x61, 0xa4, 0xd7, 0x51, 0x75, 0x9a, 0xf2, 0x1e, 0xeb, 0x58, 0xf1, 0x94, 0xc3, 0x2f, 0x56, 0xf7, 0xe6, 0x86, 0x47, 0xfb, 0x83, 0x5e, 0xcc, 0x21, 0x4a, 0x24, 0x07, 0x1c, 0x8a, 0x5a, 0x17, 0x1b, 0xda, 0xec, 0x38, 0x0e, 0x7e, 0xb4, 0x48, 0x88, 0xf4, 0xb8, 0x27, 0x91, 0x00, 0x13, 0x97, 0xbe, 0x53, 0xc2, 0xe8, 0xea, 0x1a, 0xe9, 0x2d, 0x14, 0x0b, 0xbf, 0xb5, 0x40, 0x79, 0xd2, 0x3e, 0x19, 0x5d, 0xf8, 0x69, 0x39, 0x5f, 0xdb, 0xfa, 0xb2, 0x8b, 0x6e, 0xa2, 0xdf, 0x16, 0xe2, 0x63, 0xb1, 0x20, 0xcb, 0xba, 0xee, 0x8d, 0xaa, 0xc8, 0xc7, 0xc5, 0x05, 0x66, 0x6d, 0x3a, 0x45, 0x72, 0x0d, 0xca, 0x84, 0x4e, 0xf5, 0x31, 0x6b, 0x92, 0xdc, 0xdd, 0x9c, 0x3f, 0x55, 0x96, 0xa1, 0x9f, 0xcd, 0x9b, 0xe3, 0xa0, 0xa7, 0xfc, 0xc1, 0x78, 0x10, 0x2e, 0x82, 0x8f, 0x30, 0x54, 0x04, 0xac, 0x41, 0x93, 0xd3, 0x3b, 0xef, 0x03, 0x81, 0x70, 0xa6, 0x1f, 0x22, 0x26, 0x28, 0x6a, 0xab, 0x87, 0xad, 0x49, 0x0f, 0xaf ]   得到flag2：\n第三部分解密 第三部分字符串发现就是直接进行strncmp:\n可以得到第三部分的字符串为：5mcsM\u0026lt;，最终flag：\nACTF{yOu0y*_knowo3_5mcsM\u0026lt;}\nExp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  flag_prefix = \u0026#39;ACTF{\u0026#39; flag_suffix = \u0026#39;}\u0026#39; flag3 = \u0026#39;5mcsM\u0026lt;\u0026#39; a = \u0026#39;3@1b;b\u0026#39; b = \u0026#39;elcome\u0026#39; flag1 = \u0026#39;\u0026#39; for i in range(0, len(a)): flag1 += chr((ord(a[i]) ^ ord(b[i])) + 0x23) res2 = [0x30,4,4,3,0x30,0x63] flag2 = \u0026#39;\u0026#39; byte_405018 = [ 0xf6, 0xa3, 0x5b, 0x9d, 0xe0, 0x95, 0x98, 0x68, 0x8c, 0x65, 0xbb, 0x76, 0x89, 0xd4, 0x09, 0xfd, 0xf3, 0x5c, 0x3c, 0x4c, 0x36, 0x8e, 0x4d, 0xc4, 0x80, 0x44, 0xd6, 0xa9, 0x01, 0x32, 0x77, 0x29, 0x90, 0xbc, 0xc0, 0xa8, 0xd8, 0xf9, 0xe1, 0x1d, 0xe4, 0x67, 0x7d, 0x2a, 0x2c, 0x59, 0x9e, 0x3d, 0x7a, 0x34, 0x11, 0x43, 0x74, 0xd1, 0x62, 0x60, 0x02, 0x4b, 0xae, 0x99, 0x57, 0xc6, 0x73, 0xb0, 0x33, 0x18, 0x2b, 0xfe, 0xb9, 0x85, 0xb6, 0xd9, 0xde, 0x7b, 0xcf, 0x4f, 0xb3, 0xd5, 0x08, 0x7c, 0x0a, 0x71, 0x12, 0x06, 0x37, 0xff, 0x7f, 0xb7, 0x46, 0x42, 0x25, 0xc9, 0xd0, 0x50, 0x52, 0xce, 0xbd, 0x6c, 0xe5, 0x6f, 0xa5, 0x15, 0xed, 0x64, 0xf0, 0x23, 0x35, 0xe7, 0x0c, 0x61, 0xa4, 0xd7, 0x51, 0x75, 0x9a, 0xf2, 0x1e, 0xeb, 0x58, 0xf1, 0x94, 0xc3, 0x2f, 0x56, 0xf7, 0xe6, 0x86, 0x47, 0xfb, 0x83, 0x5e, 0xcc, 0x21, 0x4a, 0x24, 0x07, 0x1c, 0x8a, 0x5a, 0x17, 0x1b, 0xda, 0xec, 0x38, 0x0e, 0x7e, 0xb4, 0x48, 0x88, 0xf4, 0xb8, 0x27, 0x91, 0x00, 0x13, 0x97, 0xbe, 0x53, 0xc2, 0xe8, 0xea, 0x1a, 0xe9, 0x2d, 0x14, 0x0b, 0xbf, 0xb5, 0x40, 0x79, 0xd2, 0x3e, 0x19, 0x5d, 0xf8, 0x69, 0x39, 0x5f, 0xdb, 0xfa, 0xb2, 0x8b, 0x6e, 0xa2, 0xdf, 0x16, 0xe2, 0x63, 0xb1, 0x20, 0xcb, 0xba, 0xee, 0x8d, 0xaa, 0xc8, 0xc7, 0xc5, 0x05, 0x66, 0x6d, 0x3a, 0x45, 0x72, 0x0d, 0xca, 0x84, 0x4e, 0xf5, 0x31, 0x6b, 0x92, 0xdc, 0xdd, 0x9c, 0x3f, 0x55, 0x96, 0xa1, 0x9f, 0xcd, 0x9b, 0xe3, 0xa0, 0xa7, 0xfc, 0xc1, 0x78, 0x10, 0x2e, 0x82, 0x8f, 0x30, 0x54, 0x04, 0xac, 0x41, 0x93, 0xd3, 0x3b, 0xef, 0x03, 0x81, 0x70, 0xa6, 0x1f, 0x22, 0x26, 0x28, 0x6a, 0xab, 0x87, 0xad, 0x49, 0x0f, 0xaf ] for i in range(0, len(res2)): flag2 += chr((0x83+i)^ byte_405018.index(res2[i])) flag = flag_prefix + flag1 + \u0026#39;_\u0026#39; + flag2 + \u0026#39;_\u0026#39; + flag3 + flag_suffix print(flag)   ","date":"2022-03-01T00:00:00Z","permalink":"https://YuSec2021.github.io/p/ctf/actf2020_splendid_minecraft/","title":"Splendid_Minecraft 解析及脚本"},{"content":"Reverse中虚函数/虚表浅析 this指针 在C++的类中，需要研究一个非常重要并且特殊的指针就是this指针：\n一个简单的demo来测试一下this指针：\n1 2 3 4 5 6 7 8 9 10  int main() { struct Test{ int a; int b; int c; }; Test* test = new Test; test-\u0026gt;a = 100; printf(\u0026#34;%d\u0026#34;, *test); }   可以看到，直接取test的值就是a的值，这里的test就是this指针本身，而this指针的特性就是指向类的首地址，在对类进行内存分配时，this指针会默认指向该类的首地址：\n关于类和结构体：其底层实现是一样的，所以demo中用struct和class的结果相同\ndemo2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;iostream\u0026gt;using namespace std; struct Test { int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); }; void Test::func1() { printf(\u0026#34;func1\u0026#34;); } void Test::func2() { printf(\u0026#34;func2\u0026#34;); } void Test::func3() { printf(\u0026#34;func3\u0026#34;); } int main() { Test* test = new Test; test-\u0026gt;a = 100; test-\u0026gt;func1(); printf(\u0026#34;%d\u0026#34;, *test); }   这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名::方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为func1、func2、func3，我们注意到这里call的函数内容来自[edx]、[edx+4]、[edx+8]\nVS的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类or结构体中，如果其虚函数的数量大于1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：\n但是在VS中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：\nIDA加载该程序 直接来到main函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int __cdecl main_0(int argc, const char **argv, const char **envp) { _DWORD *v4; // [esp+Ch] [ebp-DCh]  void *v5; // [esp+14h] [ebp-D4h]  _DWORD *v6; // [esp+E0h] [ebp-8h]  __CheckForDebuggerJustMyCode(\u0026amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\u0026#34;%d\u0026#34;, *v4); return 0; }   根据源码，这一部分就是虚函数调用在IDA中的反编译结果：\n1 2 3  (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6);   这里v6是指向v4，来到v4的初始化，可以看到存在一个virtual function table也就是虚函数表：\n1 2 3 4 5  _DWORD *__thiscall sub_411880(_DWORD *this) { *this = \u0026amp;Test::`vftable\u0026#39;; return this; }   根据前面VS中的调试可以知道这个表中存放的是增量链接：\n基本上关于虚函数在IDA中的体现就介绍完了\n一道逆向题 SWPUCTF2019 easyRE，同样来到main函数，本文重点在虚函数的创建以及体现，其他部分不做分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int __cdecl main(int argc, const char **argv, const char **envp) { _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF  _DWORD *v5; // [esp+4h] [ebp-88h]  _DWORD *v6; // [esp+8h] [ebp-84h]  int v7; // [esp+Ch] [ebp-80h]  char v8[108]; // [esp+10h] [ebp-7Ch] BYREF  int v9; // [esp+88h] [ebp-4h]  if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; }   进入sub_401FE0:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  _DWORD *__thiscall sub_401FE0(_DWORD *this) { int i; // [esp+4h] [ebp-14h]  *this = \u0026amp;EASYRE::`vftable\u0026#39;; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, \u0026#34; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#34;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i \u0026lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; }   该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：\n来到校验flag的函数，可以发现存在虚函数的特征：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  BOOL __thiscall sub_4024B0(_DWORD *this, int flag) { BOOL result; // eax  this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) { (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; } return result; }   这里this指针指向的首地址是0x4124E4，根据偏移可以映射：\n1 2 3  (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -\u0026gt; 0x4124F0 -\u0026gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -\u0026gt; 0x4124FC -\u0026gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -\u0026gt; 0x41250C -\u0026gt; sub_402A00   映射：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  BOOL __thiscall sub_4024B0(_DWORD *this, int flag) { BOOL result; // eax  this[2] = flag; result = 0; if ( sub_402500() ) { sub_4026E0(); if ( sub_402A00() ) result = 1; } return result; }   End\n","date":"2022-02-25T10:16:02+08:00","permalink":"https://YuSec2021.github.io/p/tech/vfunc_vtable/","title":"虚函数以及虚表在IDA中的体现"}]