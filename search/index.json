[{"content":"[ACTF新生赛2020]Splendid_MineCraft 反编译源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // eax  char *v4; // eax  char v6; // [esp+0h] [ebp-68h]  int i; // [esp+14h] [ebp-54h]  char *v8; // [esp+18h] [ebp-50h]  char v9; // [esp+20h] [ebp-48h]  char flag[25]; // [esp+24h] [ebp-44h] BYREF  char v11[25]; // [esp+25h] [ebp-43h] BYREF  char v12; // [esp+3Dh] [ebp-2Bh]  int v13; // [esp+44h] [ebp-24h]  __int16 v14; // [esp+48h] [ebp-20h]  char v15[4]; // [esp+4Ch] [ebp-1Ch]  __int16 v16; // [esp+50h] [ebp-18h]  int v17; // [esp+54h] [ebp-14h] BYREF  __int16 v18; // [esp+58h] [ebp-10h]  int v19; // [esp+5Ch] [ebp-Ch]  __int16 v20; // [esp+60h] [ebp-8h]  sub_401020(\u0026#34;%s\\n\u0026#34;, (char)aWelcomeToActfS); sub_401050(\u0026#34;%s\u0026#34;, (char)flag); if ( \u0026amp;flag[strlen(flag) + 1] - v11 == 26 \u0026amp;\u0026amp; !strncmp(flag, \u0026#34;ACTF{\u0026#34;, 5u) \u0026amp;\u0026amp; v12 == \u0026#39;}\u0026#39; ) { v12 = 0; v3 = strtok(flag, \u0026#34;_\u0026#34;); v17 = *(_DWORD *)(v3 + 5); v18 = *(_WORD *)(v3 + 9); v19 = *(_DWORD *)(v3 + 5); v20 = *(_WORD *)(v3 + 9); v4 = strtok(0, \u0026#34;_\u0026#34;); v13 = *(_DWORD *)v4; v14 = *((_WORD *)v4 + 2); v8 = strtok(0, \u0026#34;_\u0026#34;); *(_DWORD *)v15 = *(_DWORD *)v8; v16 = *((_WORD *)v8 + 2); dword_403354 = (int)\u0026amp;unk_4051D8; if ( ((int (__cdecl *)(int *))unk_4051D8)(\u0026amp;v17) ) { v9 = BYTE2(v19) ^ HIBYTE(v20) ^ v19 ^ HIBYTE(v19) ^ BYTE1(v19) ^ v20; for ( i = 256; i \u0026lt; 496; ++i ) byte_405018[i] ^= v9; __asm { jmp eax } } } sub_401020(\u0026#34;Wrong\\n\u0026#34;, v6); return 0; }   条件判断：\n1  \u0026amp;flag[strlen(flag) + 1] - v11 == 26 \u0026amp;\u0026amp; !strncmp(flag, \u0026#34;ACTF{\u0026#34;, 5u) \u0026amp;\u0026amp; v12 == \u0026#39;}\u0026#39;   第一个判断是输入的flag的最后一个字符的地址-v11的起始地址是否等于26，应该就是需要flag的长度为26：\n1  cyclic 26 -\u0026gt; flag{aaaabaaacaaadaaaeaaa}   后面两个判断就是判断flag的格式为：ACTF{xxxx}\nstrtok，用_将字符串分隔开，v3取的是最左边的一段字符，ACTF{xxxx，注意v17是从第六个字符开始，取4个字符的长度，然后v18是从第10个字符开始，取两个字符，这样其实都可以推断出来整个flag的格式为ACTF{xxxxxx_xxxxxx_xxxxxx}\n1 2 3 4 5 6 7 8 9 10 11  v3 = strtok(flag, \u0026#34;_\u0026#34;); v17 = *(_DWORD *)(v3 + 5); v18 = *(_WORD *)(v3 + 9); v19 = *(_DWORD *)(v3 + 5); v20 = *(_WORD *)(v3 + 9); v4 = strtok(0, \u0026#34;_\u0026#34;); v13 = *(_DWORD *)v4; v14 = *((_WORD *)v4 + 2); v8 = strtok(0, \u0026#34;_\u0026#34;); *(_DWORD *)v15 = *(_DWORD *)v8; v16 = *((_WORD *)v8 + 2);   往下存在一个unk_4051D8：\n发现把unk_4051D8当成函数执行：((int (__cdecl *)(int *))unk_4051D8)(\u0026amp;v17)，说明上面的一大段数据应该是字节码，然后将v17当成参数传入该函数中，重新运行，输入ACTF{aaaaaa_bbbbbb_cccccc}，用x32dbg动态跟：\n第一个循环：\n1 2 3 4  esi = 0xE351DD for edi in range(0, 0x151): tmp = byte ptr [esi + edi + 0x1F] [esi+edi+0x1F] = tmp ^ 0x72   异或结果：\n看到EIP，发现就是通过循环解密出后面需要执行的字节码：\n解密之后的push ebp才是真正的函数开始，该函数先是往内存写值，一个是3@1b;b，一个是Welcome：\n往下对刚刚写入的字符串的进行循环异或，\n1 2 3 4 5  a = \u0026#39;3@1b;b\u0026#39; b = \u0026#39;elcome\u0026#39; res = \u0026#39;\u0026#39; for i in range(0, len(a)): res += chr(a[i] ^ b[i] + 0x23)   6次循环后得到：yOu0y*\n最后出循环，test eax, eax，说明eax是作为函数执行结果，\n重新运行执行输入：\nACTF{abcdef_hijklm_opqrst}\n处理完第一个strtok之后会得到一个字符串为：abcdefRvabcdef，中间的Rv是固定的\n三次strtok处理完之后会得到这样的结果：\n然后来到字节码部分，注意传进来的字符串为：abcdefRvabcdef\n进来之后先对字节码进行解密，解谜之后从0x9F515C开始才是函数处理的开始，注意传入的参数由EDX指向：\n随后生成3@1b;b和welcome，对这两个值进行异或再加上0x23，然后跟传入的字符串进行对比，不难发现预期值应该是两个相等的，往下走完循环拿完处理后的结果为yOu0y*\n重新运行：\n此时相等了，跳转不实现：\n将edx作为计数器来存储相等的个数，最后对比是否全部相等，将返回值置为1：\n往下来到第二个部分的验证：\n1 2  res = \u0026#39;yOu0y*\u0026#39; key = res[0] ^ res[1] ^ res[3] ^ res[0] ^ res[5] ^ res[2] =   异或之后的值作为key，然后对：405018开始的值进行异或，跟第一个函数一样，通过这个key对字节码进行解密，然后再执行，这里的内容就是第二部分字符串的验证:\n开局几个循环啥事都没干就是将输入的第二部分字符串进行memcpy，到这个位置才真正对字符串进行处理：\n往下的mov很重要，EAX此时的值为0x705018，也就是该函数的字节码首地址，这里异或的结果作为数组下标，将字节码以byte的形式存储到EBX：\n往下从0x705018+0x166取值与上面通过偏移拿到的值进行比较：\nedi作为计数器，回到异或之前可以看到ecx的值来自于edi：\n得到异或逻辑为：\n1 2 3 4 5  res2 = [0x30,4,4,3,0x30,0x63] flag2 = \u0026#39;xxxxxx\u0026#39; byte_405018 = [...] for i in range(0, len(flag2)): cmp byte_405018[flag2[i] ^ (i+0x83)], ord(str2[i])   exp：\n1 2 3 4 5  res2 = [0x30,4,4,3,0x30,0x63] flag2 = \u0026#39;\u0026#39; byte_405018 = [...] for i in range(0, len(res2)): flag2 += chr((0x83+i)^ byte_405018.index(res2[i]))   byte_405018，用Ghidra的字节复制复制下来：\n1  [ 0xf6, 0xa3, 0x5b, 0x9d, 0xe0, 0x95, 0x98, 0x68, 0x8c, 0x65, 0xbb, 0x76, 0x89, 0xd4, 0x09, 0xfd, 0xf3, 0x5c, 0x3c, 0x4c, 0x36, 0x8e, 0x4d, 0xc4, 0x80, 0x44, 0xd6, 0xa9, 0x01, 0x32, 0x77, 0x29, 0x90, 0xbc, 0xc0, 0xa8, 0xd8, 0xf9, 0xe1, 0x1d, 0xe4, 0x67, 0x7d, 0x2a, 0x2c, 0x59, 0x9e, 0x3d, 0x7a, 0x34, 0x11, 0x43, 0x74, 0xd1, 0x62, 0x60, 0x02, 0x4b, 0xae, 0x99, 0x57, 0xc6, 0x73, 0xb0, 0x33, 0x18, 0x2b, 0xfe, 0xb9, 0x85, 0xb6, 0xd9, 0xde, 0x7b, 0xcf, 0x4f, 0xb3, 0xd5, 0x08, 0x7c, 0x0a, 0x71, 0x12, 0x06, 0x37, 0xff, 0x7f, 0xb7, 0x46, 0x42, 0x25, 0xc9, 0xd0, 0x50, 0x52, 0xce, 0xbd, 0x6c, 0xe5, 0x6f, 0xa5, 0x15, 0xed, 0x64, 0xf0, 0x23, 0x35, 0xe7, 0x0c, 0x61, 0xa4, 0xd7, 0x51, 0x75, 0x9a, 0xf2, 0x1e, 0xeb, 0x58, 0xf1, 0x94, 0xc3, 0x2f, 0x56, 0xf7, 0xe6, 0x86, 0x47, 0xfb, 0x83, 0x5e, 0xcc, 0x21, 0x4a, 0x24, 0x07, 0x1c, 0x8a, 0x5a, 0x17, 0x1b, 0xda, 0xec, 0x38, 0x0e, 0x7e, 0xb4, 0x48, 0x88, 0xf4, 0xb8, 0x27, 0x91, 0x00, 0x13, 0x97, 0xbe, 0x53, 0xc2, 0xe8, 0xea, 0x1a, 0xe9, 0x2d, 0x14, 0x0b, 0xbf, 0xb5, 0x40, 0x79, 0xd2, 0x3e, 0x19, 0x5d, 0xf8, 0x69, 0x39, 0x5f, 0xdb, 0xfa, 0xb2, 0x8b, 0x6e, 0xa2, 0xdf, 0x16, 0xe2, 0x63, 0xb1, 0x20, 0xcb, 0xba, 0xee, 0x8d, 0xaa, 0xc8, 0xc7, 0xc5, 0x05, 0x66, 0x6d, 0x3a, 0x45, 0x72, 0x0d, 0xca, 0x84, 0x4e, 0xf5, 0x31, 0x6b, 0x92, 0xdc, 0xdd, 0x9c, 0x3f, 0x55, 0x96, 0xa1, 0x9f, 0xcd, 0x9b, 0xe3, 0xa0, 0xa7, 0xfc, 0xc1, 0x78, 0x10, 0x2e, 0x82, 0x8f, 0x30, 0x54, 0x04, 0xac, 0x41, 0x93, 0xd3, 0x3b, 0xef, 0x03, 0x81, 0x70, 0xa6, 0x1f, 0x22, 0x26, 0x28, 0x6a, 0xab, 0x87, 0xad, 0x49, 0x0f, 0xaf ]   得到flag2：\n第三部分字符串发现就是直接进行strncmp:\n可以得到第三部分的字符串为：5mcsM\u0026lt;，最终flag：\n1  ACTF{yOu0y*_knowo3_5mcsM\u0026lt;}   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  flag_prefix = \u0026#39;ACTF{\u0026#39; flag_suffix = \u0026#39;}\u0026#39; flag3 = \u0026#39;5mcsM\u0026lt;\u0026#39; a = \u0026#39;3@1b;b\u0026#39; b = \u0026#39;elcome\u0026#39; flag1 = \u0026#39;\u0026#39; for i in range(0, len(a)): flag1 += chr((ord(a[i]) ^ ord(b[i])) + 0x23) res2 = [0x30,4,4,3,0x30,0x63] flag2 = \u0026#39;\u0026#39; byte_405018 = [ 0xf6, 0xa3, 0x5b, 0x9d, 0xe0, 0x95, 0x98, 0x68, 0x8c, 0x65, 0xbb, 0x76, 0x89, 0xd4, 0x09, 0xfd, 0xf3, 0x5c, 0x3c, 0x4c, 0x36, 0x8e, 0x4d, 0xc4, 0x80, 0x44, 0xd6, 0xa9, 0x01, 0x32, 0x77, 0x29, 0x90, 0xbc, 0xc0, 0xa8, 0xd8, 0xf9, 0xe1, 0x1d, 0xe4, 0x67, 0x7d, 0x2a, 0x2c, 0x59, 0x9e, 0x3d, 0x7a, 0x34, 0x11, 0x43, 0x74, 0xd1, 0x62, 0x60, 0x02, 0x4b, 0xae, 0x99, 0x57, 0xc6, 0x73, 0xb0, 0x33, 0x18, 0x2b, 0xfe, 0xb9, 0x85, 0xb6, 0xd9, 0xde, 0x7b, 0xcf, 0x4f, 0xb3, 0xd5, 0x08, 0x7c, 0x0a, 0x71, 0x12, 0x06, 0x37, 0xff, 0x7f, 0xb7, 0x46, 0x42, 0x25, 0xc9, 0xd0, 0x50, 0x52, 0xce, 0xbd, 0x6c, 0xe5, 0x6f, 0xa5, 0x15, 0xed, 0x64, 0xf0, 0x23, 0x35, 0xe7, 0x0c, 0x61, 0xa4, 0xd7, 0x51, 0x75, 0x9a, 0xf2, 0x1e, 0xeb, 0x58, 0xf1, 0x94, 0xc3, 0x2f, 0x56, 0xf7, 0xe6, 0x86, 0x47, 0xfb, 0x83, 0x5e, 0xcc, 0x21, 0x4a, 0x24, 0x07, 0x1c, 0x8a, 0x5a, 0x17, 0x1b, 0xda, 0xec, 0x38, 0x0e, 0x7e, 0xb4, 0x48, 0x88, 0xf4, 0xb8, 0x27, 0x91, 0x00, 0x13, 0x97, 0xbe, 0x53, 0xc2, 0xe8, 0xea, 0x1a, 0xe9, 0x2d, 0x14, 0x0b, 0xbf, 0xb5, 0x40, 0x79, 0xd2, 0x3e, 0x19, 0x5d, 0xf8, 0x69, 0x39, 0x5f, 0xdb, 0xfa, 0xb2, 0x8b, 0x6e, 0xa2, 0xdf, 0x16, 0xe2, 0x63, 0xb1, 0x20, 0xcb, 0xba, 0xee, 0x8d, 0xaa, 0xc8, 0xc7, 0xc5, 0x05, 0x66, 0x6d, 0x3a, 0x45, 0x72, 0x0d, 0xca, 0x84, 0x4e, 0xf5, 0x31, 0x6b, 0x92, 0xdc, 0xdd, 0x9c, 0x3f, 0x55, 0x96, 0xa1, 0x9f, 0xcd, 0x9b, 0xe3, 0xa0, 0xa7, 0xfc, 0xc1, 0x78, 0x10, 0x2e, 0x82, 0x8f, 0x30, 0x54, 0x04, 0xac, 0x41, 0x93, 0xd3, 0x3b, 0xef, 0x03, 0x81, 0x70, 0xa6, 0x1f, 0x22, 0x26, 0x28, 0x6a, 0xab, 0x87, 0xad, 0x49, 0x0f, 0xaf ] for i in range(0, len(res2)): flag2 += chr((0x83+i)^ byte_405018.index(res2[i])) flag = flag_prefix + flag1 + \u0026#39;_\u0026#39; + flag2 + \u0026#39;_\u0026#39; + flag3 + flag_suffix print(flag)   ","date":"2022-02-25T10:16:02+08:00","permalink":"https://YuSec2021.github.io/p/actf%E6%96%B0%E7%94%9F%E8%B5%9B2020splendid_minecraft/","title":"[ACTF新生赛2020]Splendid_MineCraft"},{"content":"Reverse中虚函数/虚表浅析 this指针 在C++的类中，需要研究一个非常重要并且特殊的指针就是this指针：\n一个简单的demo来测试一下this指针：\n1 2 3 4 5 6 7 8 9 10  int main() { struct Test{ int a; int b; int c; }; Test* test = new Test; test-\u0026gt;a = 100; printf(\u0026#34;%d\u0026#34;, *test); }   可以看到，直接取test的值就是a的值，这里的test就是this指针本身，而this指针的特性就是指向类的首地址，在对类进行内存分配时，this指针会默认指向该类的首地址：\n关于类和结构体：其底层实现是一样的，所以demo中用struct和class的结果相同\ndemo2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;iostream\u0026gt;using namespace std; struct Test { int a; int b; int c; virtual void func1(); virtual void func2(); virtual void func3(); }; void Test::func1() { printf(\u0026#34;func1\u0026#34;); } void Test::func2() { printf(\u0026#34;func2\u0026#34;); } void Test::func3() { printf(\u0026#34;func3\u0026#34;); } int main() { Test* test = new Test; test-\u0026gt;a = 100; test-\u0026gt;func1(); printf(\u0026#34;%d\u0026#34;, *test); }   这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名::方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为func1、func2、func3，我们注意到这里call的函数内容来自[edx]、[edx+4]、[edx+8]\nVS的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类or结构体中，如果其虚函数的数量大于1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：\n但是在VS中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：\nIDA加载该程序 直接来到main函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int __cdecl main_0(int argc, const char **argv, const char **envp) { _DWORD *v4; // [esp+Ch] [ebp-DCh]  void *v5; // [esp+14h] [ebp-D4h]  _DWORD *v6; // [esp+E0h] [ebp-8h]  __CheckForDebuggerJustMyCode(\u0026amp;unk_41C066); v5 = operator new(0x10u); if ( v5 ) v4 = (_DWORD *)sub_411460(v5); else v4 = 0; v6 = v4; v4[1] = 100; (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6); sub_411442(\u0026#34;%d\u0026#34;, *v4); return 0; }   根据源码，这一部分就是虚函数调用在IDA中的反编译结果：\n1 2 3  (*(void (__thiscall **)(_DWORD *))*v6)(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 4))(v6); (*(void (__thiscall **)(_DWORD *))(*v6 + 8))(v6);   这里v6是指向v4，来到v4的初始化，可以看到存在一个virtual function table也就是虚函数表：\n1 2 3 4 5  _DWORD *__thiscall sub_411880(_DWORD *this) { *this = \u0026amp;Test::`vftable\u0026#39;; return this; }   根据前面VS中的调试可以知道这个表中存放的是增量链接：\n基本上关于虚函数在IDA中的体现就介绍完了\n一道逆向题 SWPUCTF2019 easyRE，同样来到main函数，本文重点在虚函数的创建以及体现，其他部分不做分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int __cdecl main(int argc, const char **argv, const char **envp) { _DWORD v4[28]; // [esp-6Ch] [ebp-F8h] BYREF  _DWORD *v5; // [esp+4h] [ebp-88h]  _DWORD *v6; // [esp+8h] [ebp-84h]  int v7; // [esp+Ch] [ebp-80h]  char v8[108]; // [esp+10h] [ebp-7Ch] BYREF  int v9; // [esp+88h] [ebp-4h]  if ( sub_40EF90() ) return 1; sub_4026C0(0x6Cu); sub_401FE0(v4[27], v5); v9 = 0; v6 = v4; sub_40F360(v8); sub_40F080(v4[0], v4[1]); v5 = v4; sub_40F360(v8); sub_40F150(argc, (int)argv); v7 = 0; v9 = -1; sub_4021C0(v8); return v7; }   进入sub_401FE0:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  _DWORD *__thiscall sub_401FE0(_DWORD *this) { int i; // [esp+4h] [ebp-14h]  *this = \u0026amp;EASYRE::`vftable\u0026#39;; this[1] = 0; *((_BYTE *)this + 52) = 8; *((_BYTE *)this + 53) = -22; *((_BYTE *)this + 54) = 88; *((_BYTE *)this + 55) = -34; *((_BYTE *)this + 56) = -108; *((_BYTE *)this + 57) = -48; *((_BYTE *)this + 58) = 59; *((_BYTE *)this + 59) = -66; *((_BYTE *)this + 60) = -120; *((_BYTE *)this + 61) = -44; *((_BYTE *)this + 62) = 50; *((_BYTE *)this + 63) = -74; *((_BYTE *)this + 64) = 20; *((_BYTE *)this + 65) = -126; *((_BYTE *)this + 66) = -73; *((_BYTE *)this + 67) = -81; *((_BYTE *)this + 68) = 20; *((_BYTE *)this + 69) = 84; *((_BYTE *)this + 70) = 127; *((_BYTE *)this + 71) = -49; qmemcpy(this + 18, \u0026#34; 03\\\u0026#34;3 0 203\\\u0026#34;$ \u0026#34;, 20); sub_4030A0(this + 23); sub_402DE0(this + 26); for ( i = 0; i \u0026lt; 40; ++i ) *((_BYTE *)this + i + 12) = 0; return this; }   该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：\n来到校验flag的函数，可以发现存在虚函数的特征：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  BOOL __thiscall sub_4024B0(_DWORD *this, int flag) { BOOL result; // eax  this[2] = flag; result = 0; if ( (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) ) { (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this); if ( (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) ) result = 1; } return result; }   这里this指针指向的首地址是0x4124E4，根据偏移可以映射：\n1 2 3  (*(int (__thiscall **)(_DWORD *))(*this + 0xC))(this) -\u0026gt; 0x4124F0 -\u0026gt; sub_402500 (*(void (__thiscall **)(_DWORD *))(*this + 0x18))(this) -\u0026gt; 0x4124FC -\u0026gt; sub_4026E0 (*(int (__thiscall **)(_DWORD *))(*this + 0x28))(this) -\u0026gt; 0x41250C -\u0026gt; sub_402A00   映射：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  BOOL __thiscall sub_4024B0(_DWORD *this, int flag) { BOOL result; // eax  this[2] = flag; result = 0; if ( sub_402500() ) { sub_4026E0(); if ( sub_402A00() ) result = 1; } return result; }   End\n","date":"2022-02-25T10:16:02+08:00","permalink":"https://YuSec2021.github.io/p/%E8%99%9A%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%99%9A%E8%A1%A8%E5%9C%A8ida%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0/","title":"虚函数以及虚表在IDA中的体现"},{"content":"正文测试 Welcome to my Blog, I\u0026rsquo;m a Reverse Engineer in Shanghai.\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 1 2 3  ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg)   相册语法来自 Typlog\n","date":"2021-12-01T00:00:00Z","image":"https://YuSec2021.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://YuSec2021.github.io/p/test-chinese/","title":"Chinese Test"}]