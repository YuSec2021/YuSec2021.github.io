<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://YuSec2021.github.io</id>
    <title>YuSec2021</title>
    <link href="https://YuSec2021.github.io" />
    <updated>2022-02-17T10:00:09.000Z</updated>
    <category term="Reverse" />
    <category term="C++" />
    <entry>
        <id>https://yusec2021.github.io/2022/02/17/VirtualFunction/</id>
        <title>虚函数及虚表逆向浅析</title>
        <link rel="alternate" href="https://yusec2021.github.io/2022/02/17/VirtualFunction/"/>
        <content type="html">&lt;h2 id=&#34;reverse中虚函数虚表浅析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-2&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-2&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼1–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼2–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼3–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼4–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼5–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼6–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼7–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼8–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼9–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼10–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-3&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-3&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼11–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼12–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-2&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼13–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼14–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼15–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-2&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼16–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼17–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼18–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼19–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼20–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-2&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼21–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-4&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-4&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼22–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼23–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-3&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼24–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼25–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼26–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-3&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼27–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼28–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼29–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼30–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼31–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-3&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-3&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-5&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-5&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼32–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼33–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-4&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼34–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼35–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼36–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-4&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼37–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼38–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼39–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼40–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼41–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-4&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-4&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-6&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-6&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼42–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼43–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-5&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼44–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼45–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼46–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-5&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼47–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼48–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼49–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼50–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼51–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-5&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-5&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-7&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-7&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼52–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼53–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-6&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼54–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼55–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼56–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-6&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼57–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼58–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼59–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼60–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼61–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-6&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-6&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;h3 id=&#34;ida加载该程序-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-7&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼62–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼63–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼64–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-8&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-8&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼65–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼66–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-8&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼67–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼68–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼69–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-7&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼70–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼71–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼72–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼73–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼74–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-7&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-7&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-8&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼75–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼76–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;h2 id=&#34;reverse中虚函数虚表浅析-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#reverse中虚函数虚表浅析-9&#34;&gt;#&lt;/a&gt; Reverse 中虚函数 / 虚表浅析&lt;/h2&gt;
&lt;h3 id=&#34;this指针-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#this指针-9&#34;&gt;#&lt;/a&gt; this 指针&lt;/h3&gt;
&lt;p&gt;在 C++ 的类中，需要研究一个非常重要并且特殊的指针就是 this 指针：&lt;/p&gt;
&lt;p&gt;一个简单的 demo 来测试一下 this 指针：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼77–&amp;gt;&lt;/p&gt;
&lt;p&gt;可以看到，直接取 test 的值就是 a 的值，这里的 test 就是 this 指针本身，而 this 指针的特性就是指向类的首地址，在对类进行内存分配时，this 指针会默认指向该类的首地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821809.png&#34; alt=&#34;image-202202221821809&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于类和结构体：其底层实现是一样的，所以 demo 中用 struct 和 class 的结果相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221821374.png&#34; alt=&#34;image-202202221821374&#34;&gt;&lt;/p&gt;
&lt;p&gt;demo2：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼78–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个结构体，带着三个虚函数，虚函数需要定义，通过结构体名：：方法名的形式进行定义，重点在实例化对象调用函数的位置，调试来到反汇编窗口，红框中标注的为实际调用函数的位置，这里我们在声明结构体时从上到下的声明为 &lt;code&gt;func1&lt;/code&gt; 、 &lt;code&gt;func2&lt;/code&gt; 、 &lt;code&gt;func3&lt;/code&gt; ，我们注意到这里 call 的函数内容来自 &lt;code&gt;[edx]&lt;/code&gt; 、 &lt;code&gt;[edx+4]&lt;/code&gt; 、 &lt;code&gt;[edx+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822350.png&#34; alt=&#34;image-202202221822350&#34;&gt;&lt;/p&gt;
&lt;p&gt;VS 的监视器中已经帮我们标注出来了，存在一个__vfptr，这里指针就是指向虚表的指针，对于一个类 or 结构体中，如果其虚函数的数量大于 1，那么编译器在初始化时会自动创建一个虚表，用来存储函数的地址，通过代码的编写顺序进行函数索引的映射，虚表中存放的就是函数定义的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822816.png&#34; alt=&#34;image-202202221822816&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是在 VS 中默认开启了增量链接，所以此时虚表中指向的还是一个跳转地址，跳转地址之后才是函数真正的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822113.png&#34; alt=&#34;image-202202221822113&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822536.png&#34; alt=&#34;image-202202221822536&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ida加载该程序-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ida加载该程序-9&#34;&gt;#&lt;/a&gt; IDA 加载该程序&lt;/h3&gt;
&lt;p&gt;直接来到 main 函数：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼79–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据源码，这一部分就是虚函数调用在 IDA 中的反编译结果：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼80–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 v6 是指向 v4，来到 v4 的初始化，可以看到存在一个 &lt;code&gt;virtual function table&lt;/code&gt;  也就是虚函数表：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼81–&amp;gt;&lt;/p&gt;
&lt;p&gt;根据前面 VS 中的调试可以知道这个表中存放的是增量链接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822914.png&#34; alt=&#34;image-202202221822914&#34;&gt;&lt;/p&gt;
&lt;p&gt;基本上关于虚函数在 IDA 中的体现就介绍完了&lt;/p&gt;
&lt;h3 id=&#34;一道逆向题-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一道逆向题-9&#34;&gt;#&lt;/a&gt; 一道逆向题&lt;/h3&gt;
&lt;p&gt;SWPUCTF2019 easyRE，同样来到 main 函数，本文重点在虚函数的创建以及体现，其他部分不做分析：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼82–&amp;gt;&lt;/p&gt;
&lt;p&gt;进入 sub_401FE0:&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼83–&amp;gt;&lt;/p&gt;
&lt;p&gt;该题目中不存在增量链接，所以这里的虚函数表中指向的就是函数真正的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/YuSec2021/pic/raw/master/img/202202221822478.png&#34; alt=&#34;image-202202221822478&#34;&gt;&lt;/p&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼84–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼85–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼86–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-8&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-8&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
&lt;p&gt;来到校验 flag 的函数，可以发现存在虚函数的特征：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼87–&amp;gt;&lt;/p&gt;
&lt;p&gt;这里 this 指针指向的首地址是 &lt;code&gt;0x4124E4&lt;/code&gt; ，根据偏移可以映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼88–&amp;gt;&lt;/p&gt;
&lt;p&gt;映射：&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼89–&amp;gt;&lt;/p&gt;
&lt;h3 id=&#34;end-9&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#end-9&#34;&gt;#&lt;/a&gt; End&lt;/h3&gt;
</content>
        <category term="Reverse" />
        <category term="C++" />
        <updated>2022-02-17T10:00:09.000Z</updated>
    </entry>
</feed>
